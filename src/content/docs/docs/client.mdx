---
title: Accessing flows from the client
description: Learn how to access Genkit flows from client-side applications.
---

import LanguageSelector from '../../../components/LanguageSelector.astro';
import LanguageContent from '../../../components/LanguageContent.astro';
import CopyMarkdownButton from '../../../components/CopyMarkdownButton.astro';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector supportedLanguages="js dart" />
  <CopyMarkdownButton />
</div>

<LanguageContent lang="js">
There are two primary ways to access Genkit flows from client-side applications:

- Using the Genkit client library
- Cloud Functions for Firebase callable function client SDK

## Using the Genkit client library

You can call your deployed flows using the Genkit client library. This library provides functions for both non-streaming and streaming flow calls. See "Call your flows from the client" in [Deploy flows to any Node.js platform](/docs/deployment/any-platform) for more details.

### Non-streaming Flow Calls

For a non-streaming response, use the `runFlow` function. This is suitable for flows that return a single, complete output.

```typescript
import { runFlow } from 'genkit/beta/client';

async function callHelloFlow() {
  try {
    const result = await runFlow({
      url: 'http://127.0.0.1:3400/helloFlow', // Replace with your deployed flow's URL
      input: { name: 'Genkit User' },
    });
    console.log('Non-streaming result:', result.greeting);
  } catch (error) {
    console.error('Error calling helloFlow:', error);
  }
}

callHelloFlow();
```

### Streaming Flow Calls

For flows that are designed to stream responses (e.g., for real-time updates or long-running operations), use the `streamFlow` function.

```typescript
import { streamFlow } from 'genkit/beta/client';

async function streamHelloFlow() {
  try {
    const result = streamFlow({
      url: 'http://127.0.0.1:3400/helloFlow', // Replace with your deployed flow's URL
      input: { name: 'Streaming User' },
    });

    // Process the stream chunks as they arrive
    for await (const chunk of result.stream) {
      console.log('Stream chunk:', chunk);
    }

    // Get the final complete response
    const finalOutput = await result.output;
    console.log('Final streaming output:', finalOutput.greeting);
  } catch (error) {
    console.error('Error streaming helloFlow:', error);
  }
}

streamHelloFlow();
```

### Authentication (Optional)

If your deployed flow requires authentication, you can pass headers with your requests:

```typescript
const result = await runFlow({
  url: 'http://127.0.0.1:3400/helloFlow', // Replace with your deployed flow's URL
  headers: {
    Authorization: 'Bearer your-token-here', // Replace with your actual token
  },
  input: { name: 'Authenticated User' },
});
```

## When deploying to Cloud Functions for Firebase

When deploying to [Cloud Functions for Firebase](/docs/deployment/firebase), use the Firebase callable functions client library.

Detailed documentation can be found at https://firebase.google.com/docs/functions/callable?gen=2nd

Here's a sample for the web:

```typescript
// Get the callable by passing an initialized functions SDK.
const getForecast = httpsCallable(functions, 'getForecast');

// Call the function with the `.stream()` method to start streaming.
const { stream, data } = await getForecast.stream({
  locations: favoriteLocations,
});

// The `stream` async iterable returned by `.stream()`
// will yield a new value every time the callable
// function calls `sendChunk()`.
for await (const forecastDataChunk of stream) {
  // update the UI every time a new chunk is received
  // from the callable function
  updateUi(forecastDataChunk);
}

// The `data` promise resolves when the callable
// function completes.
const allWeatherForecasts = await data;
finalizeUi(allWeatherForecasts);
```

[source](https://github.com/firebase/functions-samples/blob/c4fde45b65fab584715e786ce3264a6932d996ec/Node/quickstarts/callable-functions-streaming/website/index.html#L58-L78)
</LanguageContent>
<LanguageContent lang="dart">
There are two primary ways to access Genkit flows from client-side applications:

- Using the Genkit Dart client library
- Cloud Functions for Firebase callable function client SDK

## Using the Genkit client library

You can call your deployed flows using the Genkit Dart client library. This library provides a type-safe way to interact with both non-streaming and streaming flows.

First, you define a remote action that represents your deployed flow:

```dart
import 'package:genkit/client.dart';

// Define a remote action for a flow
final helloFlow = defineRemoteAction(
  url: 'http://127.0.0.1:3400/helloFlow', // Replace with your deployed flow's URL
  fromResponse: (data) => data['greeting'] as String,
);
```

### Non-streaming Flow Calls

For a non-streaming response, `await` the action. This is suitable for flows that return a single, complete output.

```dart
// main.dart
import 'package:genkit/client.dart';

// Define the action (as shown above)
final helloFlow = defineRemoteAction(
  url: 'http://127.0.0.1:3400/helloFlow',
  fromResponse: (data) => data['greeting'] as String,
);

Future<void> callHelloFlow() async {
  try {
    final result = await helloFlow(input: {'name': 'Genkit User'});
    print('Non-streaming result: $result');
  } catch (e) {
    print('Error calling helloFlow: $e');
  }
}
```

### Streaming Flow Calls

For flows that are designed to stream responses, use the `.stream()` method on the action.

```dart
// main.dart
import 'package:genkit/client.dart';

// Define the action with a chunk decoder
final helloFlow = defineRemoteAction(
  url: 'http://127.0.0.1:3400/helloFlow',
  fromResponse: (data) => data['greeting'] as String,
  fromStreamChunk: (chunk) => chunk as String,
);

Future<void> streamHelloFlow() async {
  try {
    final result = helloFlow.stream(input: {'name': 'Streaming User'});

    // Process the stream chunks as they arrive
    await for (final chunk in result) {
      print('Stream chunk: $chunk');
    }

    // Get the final complete response
    final finalOutput = await result.onResult;
    print('Final streaming output: $finalOutput');
  } catch (e) {
    print('Error streaming helloFlow: $e');
  }
}
```

#### Custom Object Streaming

You can also stream custom objects. Make sure you have the necessary `fromJson` factories for your classes. For robust JSON serialization, it's recommended to use a code generation library like [`json_serializable`](https://pub.dev/packages/json_serializable).

```dart
class StreamChunk {
  final String content;
  
  StreamChunk({required this.content});
  
  factory StreamChunk.fromJson(Map<String, dynamic> json) => StreamChunk(
    content: json['content'] as String,
  );
}

// Assumes MyOutput and MyInput classes are defined as in the non-streaming example
final streamAction = defineRemoteAction(
  url: 'http://localhost:3400/stream-process',
  fromResponse: (data) => MyOutput.fromJson(data),
  fromStreamChunk: (data) => StreamChunk.fromJson(data),
);

final input = MyInput(message: 'Stream this data', count: 5);

try {
  final stream = streamAction.stream(input: input);

  print('Streaming chunks:');
  await for (final chunk in stream) {
    print('Chunk: ${chunk.content}');
  }

  final finalResult = await stream.onResult;
  print('\nFinal Response: ${finalResult.reply}');
} catch (e) {
  print('Error calling streaming flow: $e');
}
```

#### Working with Genkit Data Objects

When interacting with Genkit models, you'll often work with standardized data classes like `GenerateResponse` and `GenerateResponseChunk`. The client library provides these classes for type-safe interaction.

```dart
import 'package:genkit/client.dart';

final generateFlow = defineRemoteAction(
  url: 'http://localhost:3400/generate',
  fromResponse: (json) => GenerateResponse.fromJson(json),
  fromStreamChunk: (json) => GenerateResponseChunk.fromJson(json),
);

final stream = generateFlow.stream(
  input: Message(role: Role.user, content: [TextPart(text: "hello")]),
);

print('Streaming chunks:');
await for (final chunk in stream) {
  // Use the .text getter to easily access the text content of the chunk
  print('Chunk: ${chunk.text}');
}

final finalResult = await stream.onResult;
// The .text getter also works on the final response
print('Final Response: ${finalResult.text}');
```

### Authentication (Optional)

If your deployed flow requires authentication, you can pass headers with your requests:

```dart
// For non-streaming calls
final result = await helloFlow(
  input: {'name': 'Authenticated User'},
  headers: {'Authorization': 'Bearer your-token-here'},
);

// For streaming calls
final streamResult = helloFlow.stream(
  input: {'name': 'Authenticated User'},
  headers: {'Authorization': 'Bearer your-token-here'},
);
```

## When deploying to Cloud Functions for Firebase

When deploying to [Cloud Functions for Firebase](/docs/deployment/firebase), use the Firebase callable functions client library.

Detailed documentation can be found at https://firebase.google.com/docs/functions/callable?gen=2nd

An official Dart client for callable functions is available at https://pub.dev/packages/cloud_functions.
</LanguageContent>
