---
title: Express.js Integration
description: Learn how to integrate Genkit with Express.js applications across JavaScript, Go, and Python, including REST API endpoints, authentication, and deployment strategies.
---

import LanguageSelector from '../../../../components/LanguageSelector.astro';
import CopyMarkdownButton from '../../../../components/CopyMarkdownButton.astro';
import LanguageContent from '../../../../components/LanguageContent.astro';
import { Badge } from '@astrojs/starlight/components';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector />
  <CopyMarkdownButton />
</div>

<Badge text="JavaScript Primary" variant="note" />

The Express.js integration allows you to expose Genkit flows and actions as REST API endpoints, making it easy to integrate AI capabilities into existing Express-based backends or deploy them to any platform that supports Express.js applications.

:::note[Framework Availability]
Express.js integration is primarily available for JavaScript/Node.js. For other languages, see equivalent frameworks:
- **Go**: Gin or standard `net/http`
- **Python**: Flask or FastAPI
:::

## Installation and Setup

<LanguageContent lang="js">
Install the Express plugin:

    ```bash
    npm install @genkit-ai/express express
    npm install -D @types/express  # if using TypeScript
    ```

    Basic setup with Express integration:

    ```ts
    import { genkit, z } from 'genkit';
    import { googleAI } from '@genkit-ai/googleai';
    import { expressHandler } from '@genkit-ai/express';
    import express from 'express';

    const ai = genkit({
      plugins: [googleAI()],
      model: googleAI.model('gemini-2.5-flash'),
    });

    // Define a Genkit flow
    const simpleFlow = ai.defineFlow(
      {
        name: 'simpleFlow',
        inputSchema: z.object({ input: z.string() }),
        outputSchema: z.object({ output: z.string() }),
      },
      async ({ input }, { sendChunk }) => {
        const { text } = await ai.generate({
          prompt: input,
          onChunk: (c) => sendChunk(c.text),
        });
        return { output: text };
      },
    );

    // Create Express app
    const app = express();
    app.use(express.json());

    // Expose Genkit flow as REST endpoint
    app.post('/simpleFlow', expressHandler(simpleFlow));

    app.listen(8080, () => {
      console.log('Express server listening on port 8080');
    });
    ```
</LanguageContent>

<LanguageContent lang="go">
For Go applications, use Gin or standard HTTP handlers. Here's an equivalent setup:

    ```go
    package main

    import (
        "context"
        "encoding/json"
        "net/http"
        "github.com/gin-gonic/gin"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/ai"
        "github.com/firebase/genkit/go/plugins/googlegenai"
    )

    type FlowInput struct {
        Input string `json:"input"`
    }

    type FlowOutput struct {
        Output string `json:"output"`
    }

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(&googlegenai.GoogleAI{}),
        )
        if err != nil {
            log.Fatal(err)
        }

        // Define flow
        simpleFlow := genkit.DefineFlow(g, "simpleFlow",
            func(ctx context.Context, input FlowInput) (FlowOutput, error) {
                resp, err := genkit.Generate(ctx, g,
                    ai.WithPrompt(input.Input),
                )
                if err != nil {
                    return FlowOutput{}, err
                }
                return FlowOutput{Output: resp.Text()}, nil
            },
        )

        // Setup Gin router
        r := gin.Default()
        
        r.POST("/simpleFlow", func(c *gin.Context) {
            var input FlowInput
            if err := c.ShouldBindJSON(&input); err != nil {
                c.JSON(400, gin.H{"error": err.Error()})
                return
            }

            result, err := simpleFlow.Run(ctx, input)
            if err != nil {
                c.JSON(500, gin.H{"error": err.Error()})
                return
            }

            c.JSON(200, result)
        })

        r.Run(":8080")
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
For Python applications, use Flask or FastAPI. Here's a Flask equivalent:

    ```python
    from flask import Flask, request, jsonify
    from genkit.ai import Genkit
    from genkit.plugins.google_genai import GoogleGenai

    ai = Genkit(
        plugins=[GoogleGenai()],
    )

    # Define flow
    @ai.define_flow(
        input_schema={"input": str},
        output_schema={"output": str}
    )
    async def simple_flow(input_data):
        response = await ai.generate(input_data["input"])
        return {"output": response.text}

    # Create Flask app
    app = Flask(__name__)

    @app.route('/simpleFlow', methods=['POST'])
    async def handle_simple_flow():
        try:
            input_data = request.get_json()
            result = await simple_flow(input_data)
            return jsonify(result)
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080)
    ```
</LanguageContent>

## Client Integration

<LanguageContent lang="js">
Access your Express-hosted flows from client applications:

    ```ts
    import { runFlow, streamFlow } from 'genkit/beta/client';

    // Basic flow execution
    const result = await runFlow({
      url: 'http://localhost:8080/simpleFlow',
      input: { input: 'Tell me a joke about programming' },
    });
    console.log(result); // { output: "Why do programmers prefer dark mode?..." }

    // Streaming flow execution
    const streamResult = streamFlow({
      url: 'http://localhost:8080/simpleFlow',
      input: { input: 'Write a story about AI' },
    });

    for await (const chunk of streamResult.stream) {
      console.log('Chunk:', chunk);
    }

    const finalResult = await streamResult.output;
    console.log('Final result:', finalResult);
    ```

    ### Frontend Integration

    ```ts
    // React component example
    import React, { useState } from 'react';
    import { runFlow } from 'genkit/beta/client';

    function AIChat() {
      const [input, setInput] = useState('');
      const [output, setOutput] = useState('');
      const [loading, setLoading] = useState(false);

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        
        try {
          const result = await runFlow({
            url: '/api/simpleFlow',
            input: { input },
          });
          setOutput(result.output);
        } catch (error) {
          console.error('Error:', error);
        } finally {
          setLoading(false);
        }
      };

      return (
        <form onSubmit={handleSubmit}>
          <input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask me anything..."
          />
          <button type="submit" disabled={loading}>
            {loading ? 'Thinking...' : 'Send'}
          </button>
          {output && <div className="response">{output}</div>}
        </form>
      );
    }
    ```
</LanguageContent>

<LanguageContent lang="go">
Access your Go HTTP endpoints from client applications:

    ```go
    package main

    import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
    )

    type FlowRequest struct {
        Input string `json:"input"`
    }

    type FlowResponse struct {
        Output string `json:"output"`
    }

    func callFlow(input string) (*FlowResponse, error) {
        reqBody := FlowRequest{Input: input}
        jsonData, err := json.Marshal(reqBody)
        if err != nil {
            return nil, err
        }

        resp, err := http.Post(
            "http://localhost:8080/simpleFlow",
            "application/json",
            bytes.NewBuffer(jsonData),
        )
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var result FlowResponse
        err = json.NewDecoder(resp.Body).Decode(&result)
        if err != nil {
            return nil, err
        }

        return &result, nil
    }

    func main() {
        result, err := callFlow("Tell me a joke about programming")
        if err != nil {
            fmt.Printf("Error: %v\n", err)
            return
        }
        fmt.Printf("Response: %s\n", result.Output)
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
Access your Python Flask endpoints from client applications:

    ```python
    import requests
    import asyncio
    import aiohttp

    # Synchronous client
    def call_flow(input_text):
        response = requests.post(
            'http://localhost:8080/simpleFlow',
            json={'input': input_text}
        )
        response.raise_for_status()
        return response.json()

    # Asynchronous client
    async def call_flow_async(input_text):
        async with aiohttp.ClientSession() as session:
            async with session.post(
                'http://localhost:8080/simpleFlow',
                json={'input': input_text}
            ) as response:
                response.raise_for_status()
                return await response.json()

    # Usage
    result = call_flow("Tell me a joke about programming")
    print(result['output'])

    # Async usage
    async def main():
        result = await call_flow_async("Write a story about AI")
        print(result['output'])

    asyncio.run(main())
    ```
</LanguageContent>

## Authentication and Security

<LanguageContent lang="js">
Implement authentication for your Express endpoints:

    ### API Key Authentication

    ```ts
    import { apiKey } from 'genkit/context';
    import { startFlowServer, withContextProvider } from '@genkit-ai/express';

    const securedFlow = ai.defineFlow(
      {
        name: 'securedFlow',
        inputSchema: z.object({ sensitiveData: z.string() }),
        outputSchema: z.object({ output: z.string() }),
      },
      async ({ sensitiveData }, { context }) => {
        // Flow is automatically secured by API key check
        return { output: 'This is protected content' };
      }
    );

    // Secure with API key
    startFlowServer({
      flows: [withContextProvider(securedFlow, apiKey(process.env.MY_API_KEY))],
      port: 8080,
    });
    ```

    ### Custom Authentication

    ```ts
    import { ContextProvider, RequestData, UserFacingError } from 'genkit/context';

    interface AuthContext {
      auth?: {
        user: string;
        role: string;
      };
    }

    const customAuth: ContextProvider<AuthContext> = async (req: RequestData) => {
      const token = req.headers['authorization']?.replace('Bearer ', '');
      
      if (!token) {
        throw new UserFacingError('UNAUTHENTICATED', 'Missing authorization token');
      }

      // Verify token (implement your own logic)
      const user = await verifyJWT(token);
      
      return {
        auth: {
          user: user.id,
          role: user.role,
        },
      };
    };

    const protectedFlow = ai.defineFlow(
      {
        name: 'protectedFlow',
        inputSchema: z.object({ input: z.string() }),
        outputSchema: z.object({ output: z.string() }),
      },
      async ({ input }, { context }) => {
        if (!context.auth || context.auth.role !== 'admin') {
          throw new Error('Admin access required');
        }
        
        return { output: `Hello ${context.auth.user}, you said: ${input}` };
      }
    );

    startFlowServer({
      flows: [withContextProvider(protectedFlow, customAuth)],
    });
    ```

    ### Express Middleware Integration

    ```ts
    import express from 'express';
    import jwt from 'jsonwebtoken';

    const app = express();
    app.use(express.json());

    // Custom auth middleware
    const authMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => {
      const token = req.headers.authorization?.replace('Bearer ', '');
      
      if (!token) {
        return res.status(401).json({ error: 'Missing token' });
      }

      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET!);
        req.user = decoded;
        next();
      } catch (error) {
        return res.status(401).json({ error: 'Invalid token' });
      }
    };

    // Protected endpoint
    app.post('/protectedFlow', authMiddleware, expressHandler(protectedFlow));
    ```
</LanguageContent>

<LanguageContent lang="go">
Implement authentication in Go applications:

    ```go
    import (
        "net/http"
        "strings"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v4"
    )

    func authMiddleware() gin.HandlerFunc {
        return func(c *gin.Context) {
            authHeader := c.GetHeader("Authorization")
            if authHeader == "" {
                c.JSON(401, gin.H{"error": "Missing authorization header"})
                c.Abort()
                return
            }

            tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
            
            token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
                return []byte(os.Getenv("JWT_SECRET")), nil
            })

            if err != nil || !token.Valid {
                c.JSON(401, gin.H{"error": "Invalid token"})
                c.Abort()
                return
            }

            if claims, ok := token.Claims.(jwt.MapClaims); ok {
                c.Set("user", claims)
            }

            c.Next()
        }
    }

    func main() {
        r := gin.Default()
        
        // Protected route
        r.POST("/protectedFlow", authMiddleware(), func(c *gin.Context) {
            user, _ := c.Get("user")
            // Handle protected flow logic
            c.JSON(200, gin.H{"message": "Protected content", "user": user})
        })

        r.Run(":8080")
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
Implement authentication in Flask applications:

    ```python
    from flask import Flask, request, jsonify
    from functools import wraps
    import jwt
    import os

    app = Flask(__name__)

    def auth_required(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get('Authorization')
            if not token:
                return jsonify({'error': 'Missing authorization header'}), 401
            
            try:
                token = token.replace('Bearer ', '')
                payload = jwt.decode(token, os.getenv('JWT_SECRET'), algorithms=['HS256'])
                request.user = payload
            except jwt.InvalidTokenError:
                return jsonify({'error': 'Invalid token'}), 401
            
            return f(*args, **kwargs)
        return decorated_function

    @app.route('/protectedFlow', methods=['POST'])
    @auth_required
    async def protected_flow():
        user = request.user
        input_data = request.get_json()
        
        # Handle protected flow logic
        result = await handle_protected_flow(input_data, user)
        return jsonify(result)
    ```
</LanguageContent>

## Advanced Features

### Multiple Flows and Server Configuration

<LanguageContent lang="js">
Use `startFlowServer` for multiple flows with advanced configuration:

    ```ts
    import { startFlowServer } from '@genkit-ai/express';

    const chatFlow = ai.defineFlow(
      {
        name: 'chatFlow',
        inputSchema: z.object({ message: z.string() }),
        outputSchema: z.object({ response: z.string() }),
      },
      async ({ message }) => {
        const { text } = await ai.generate({
          prompt: `Respond to this message: ${message}`,
        });
        return { response: text };
      }
    );

    const summaryFlow = ai.defineFlow(
      {
        name: 'summaryFlow',
        inputSchema: z.object({ text: z.string() }),
        outputSchema: z.object({ summary: z.string() }),
      },
      async ({ text }) => {
        const { text: summary } = await ai.generate({
          prompt: `Summarize this text: ${text}`,
        });
        return { summary };
      }
    );

    startFlowServer({
      flows: [chatFlow, summaryFlow],
      port: 4567,
      cors: {
        origin: ['http://localhost:3000', 'https://myapp.com'],
        credentials: true,
      },
      pathPrefix: '/api/v1',
      jsonParserOptions: {
        limit: '10mb',
      },
    });
    ```
</LanguageContent>

<LanguageContent lang="go">
Configure multiple endpoints with Gin:

    ```go
    func setupRoutes() *gin.Engine {
        r := gin.Default()
        
        // CORS middleware
        r.Use(func(c *gin.Context) {
            c.Header("Access-Control-Allow-Origin", "*")
            c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
            c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
            
            if c.Request.Method == "OPTIONS" {
                c.AbortWithStatus(204)
                return
            }
            
            c.Next()
        })

        // API group
        api := r.Group("/api/v1")
        {
            api.POST("/chat", handleChatFlow)
            api.POST("/summary", handleSummaryFlow)
        }

        return r
    }

    func main() {
        r := setupRoutes()
        r.Run(":4567")
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
Configure multiple endpoints with Flask:

    ```python
    from flask import Flask
    from flask_cors import CORS

    app = Flask(__name__)
    CORS(app, origins=['http://localhost:3000', 'https://myapp.com'])

    @app.route('/api/v1/chat', methods=['POST'])
    async def chat_flow():
        input_data = request.get_json()
        result = await handle_chat_flow(input_data)
        return jsonify(result)

    @app.route('/api/v1/summary', methods=['POST'])
    async def summary_flow():
        input_data = request.get_json()
        result = await handle_summary_flow(input_data)
        return jsonify(result)

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=4567)
    ```
</LanguageContent>

### Error Handling and Validation

<LanguageContent lang="js">
Implement comprehensive error handling:

    ```ts
    import { UserFacingError } from 'genkit';

    const robustFlow = ai.defineFlow(
      {
        name: 'robustFlow',
        inputSchema: z.object({
          text: z.string().min(1).max(1000),
          options: z.object({
            temperature: z.number().min(0).max(2).optional(),
          }).optional(),
        }),
        outputSchema: z.object({ result: z.string() }),
      },
      async ({ text, options }, { context }) => {
        try {
          const { text: result } = await ai.generate({
            prompt: text,
            config: {
              temperature: options?.temperature ?? 0.7,
            },
          });
          
          return { result };
        } catch (error) {
          if (error.message.includes('rate limit')) {
            throw new UserFacingError('RESOURCE_EXHAUSTED', 'Rate limit exceeded. Please try again later.');
          }
          
          throw new UserFacingError('INTERNAL', 'An unexpected error occurred.');
        }
      }
    );

    // Custom error handling middleware
    app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
      if (error instanceof UserFacingError) {
        return res.status(400).json({
          error: error.message,
          code: error.code,
        });
      }
      
      console.error('Unexpected error:', error);
      res.status(500).json({
        error: 'Internal server error',
      });
    });
    ```
</LanguageContent>

<LanguageContent lang="go">
Implement error handling in Go:

    ```go
    type ErrorResponse struct {
        Error string `json:"error"`
        Code  string `json:"code,omitempty"`
    }

    func handleFlowWithValidation(c *gin.Context) {
        var input struct {
            Text    string `json:"text" binding:"required,min=1,max=1000"`
            Options struct {
                Temperature *float64 `json:"temperature,omitempty"`
            } `json:"options,omitempty"`
        }

        if err := c.ShouldBindJSON(&input); err != nil {
            c.JSON(400, ErrorResponse{
                Error: "Invalid input: " + err.Error(),
                Code:  "INVALID_ARGUMENT",
            })
            return
        }

        result, err := processFlow(input.Text, input.Options.Temperature)
        if err != nil {
            if strings.Contains(err.Error(), "rate limit") {
                c.JSON(429, ErrorResponse{
                    Error: "Rate limit exceeded. Please try again later.",
                    Code:  "RESOURCE_EXHAUSTED",
                })
                return
            }
            
            c.JSON(500, ErrorResponse{
                Error: "Internal server error",
                Code:  "INTERNAL",
            })
            return
        }

        c.JSON(200, gin.H{"result": result})
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
Implement error handling in Flask:

    ```python
    from flask import Flask, request, jsonify
    from marshmallow import Schema, fields, ValidationError

    class FlowInputSchema(Schema):
        text = fields.Str(required=True, validate=lambda x: 1 <= len(x) <= 1000)
        options = fields.Dict(missing={})

    schema = FlowInputSchema()

    @app.route('/robustFlow', methods=['POST'])
    async def robust_flow():
        try:
            # Validate input
            input_data = schema.load(request.get_json())
            
            # Process flow
            result = await process_flow(
                input_data['text'],
                input_data['options'].get('temperature', 0.7)
            )
            
            return jsonify({'result': result})
            
        except ValidationError as err:
            return jsonify({
                'error': 'Invalid input',
                'details': err.messages,
                'code': 'INVALID_ARGUMENT'
            }), 400
            
        except Exception as err:
            if 'rate limit' in str(err):
                return jsonify({
                    'error': 'Rate limit exceeded. Please try again later.',
                    'code': 'RESOURCE_EXHAUSTED'
                }), 429
            
            return jsonify({
                'error': 'Internal server error',
                'code': 'INTERNAL'
            }), 500
    ```
</LanguageContent>

## Deployment Considerations

### Production Configuration

<LanguageContent lang="js">
Production-ready Express setup:

    ```ts
    import helmet from 'helmet';
    import compression from 'compression';
    import rateLimit from 'express-rate-limit';

    const app = express();

    // Security middleware
    app.use(helmet());
    app.use(compression());

    // Rate limiting
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // limit each IP to 100 requests per windowMs
      message: 'Too many requests from this IP',
    });
    app.use('/api/', limiter);

    // Body parsing with limits
    app.use(express.json({ limit: '10mb' }));

    // Health check endpoint
    app.get('/health', (req, res) => {
      res.json({ status: 'healthy', timestamp: new Date().toISOString() });
    });

    // Start server
    const port = process.env.PORT || 8080;
    app.listen(port, () => {
      console.log(`Server running on port ${port}`);
    });
    ```
</LanguageContent>

<LanguageContent lang="go">
Production-ready Go setup:

    ```go
    import (
        "time"
        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/gzip"
        "golang.org/x/time/rate"
    )

    func setupProductionServer() *gin.Engine {
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        
        // Middleware
        r.Use(gin.Logger())
        r.Use(gin.Recovery())
        r.Use(gzip.Gzip(gzip.DefaultCompression))
        
        // CORS
        r.Use(cors.New(cors.Config{
            AllowOrigins:     []string{"https://myapp.com"},
            AllowMethods:     []string{"POST", "GET"},
            AllowHeaders:     []string{"Content-Type", "Authorization"},
            ExposeHeaders:    []string{"Content-Length"},
            AllowCredentials: true,
            MaxAge:           12 * time.Hour,
        }))

        // Rate limiting middleware
        limiter := rate.NewLimiter(rate.Every(time.Minute), 60)
        r.Use(func(c *gin.Context) {
            if !limiter.Allow() {
                c.JSON(429, gin.H{"error": "Rate limit exceeded"})
                c.Abort()
                return
            }
            c.Next()
        })

        // Health check
        r.GET("/health", func(c *gin.Context) {
            c.JSON(200, gin.H{
                "status":    "healthy",
                "timestamp": time.Now().Format(time.RFC3339),
            })
        })

        return r
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
Production-ready Flask setup:

    ```python
    from flask import Flask
    from flask_cors import CORS
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    import os

    app = Flask(__name__)

    # CORS
    CORS(app, origins=['https://myapp.com'])

    # Rate limiting
    limiter = Limiter(
        app,
        key_func=get_remote_address,
        default_limits=["100 per hour"]
    )

    @app.route('/health')
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat()
        })

    @app.errorhandler(429)
    def ratelimit_handler(e):
        return jsonify({'error': 'Rate limit exceeded'}), 429

    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8080))
        app.run(host='0.0.0.0', port=port, debug=False)
    ```
</LanguageContent>

## Next Steps

- Learn about [creating flows](/docs/flows) to build more complex AI workflows
- Explore [authorization patterns](/docs/deployment/authorization) for securing your applications
- See [deployment guides](/docs/deployment) for production deployment strategies
- Check out other framework integrations:
  - [Next.js](/docs/frameworks/nextjs) for React applications
