---
title: Next.js Integration
description: Learn how to integrate Genkit with Next.js applications across JavaScript, Go, and Python, including API routes, client-side calls, streaming, and deployment strategies.
---

import LanguageSelector from '../../../../components/LanguageSelector.astro';
import CopyMarkdownButton from '../../../../components/CopyMarkdownButton.astro';
import LanguageContent from '../../../../components/LanguageContent.astro';
import { Badge } from '@astrojs/starlight/components';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector />
  <CopyMarkdownButton />
</div>

<Badge text="JavaScript Primary" variant="note" />

The Next.js integration provides a seamless way to build full-stack AI applications with Genkit, offering both server-side API routes and client-side streaming capabilities for modern React applications.

:::note[Framework Availability]
Next.js integration is primarily available for JavaScript/Node.js. For other languages, see equivalent frameworks:

- **Go**: Gin with React frontend
- **Python**: FastAPI with React frontend
  :::

## Installation and Setup

<LanguageContent lang="js">
### Create a Next.js Project

    If you don't have an existing Next.js project:

    ```bash
    npx create-next-app@latest my-genkit-app --src-dir --typescript
    cd my-genkit-app
    ```

    ### Install Dependencies

    ```bash
    # Core Genkit and Next.js plugin
    npm install genkit @genkit-ai/next

    # Choose your AI provider
    npm install @genkit-ai/googleai
    # or npm install @genkit-ai/vertexai
    # or npm install @genkit-ai/compat-oai

    # Development tools (optional)
    npm install -g genkit-cli
    npm install --save-dev tsx
    ```

    ### Project Structure

    ```
    my-genkit-app/
    ├── src/
    │   ├── app/
    │   │   ├── api/
    │   │   │   └── flows/
    │   │   │       └── route.ts
    │   │   └── page.tsx
    │   └── genkit/
    │       └── flows.ts
    ├── package.json
    └── next.config.js
    ```

</LanguageContent>

<LanguageContent lang="go">
For Go applications, create a separate backend API and React frontend:

    ### Backend Setup (Go)

    ```bash
    mkdir my-genkit-app
    cd my-genkit-app
    mkdir backend frontend
    ```

    ```go
    // backend/main.go
    package main

    import (
        "context"
        "github.com/gin-gonic/gin"
        "github.com/gin-contrib/cors"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/googlegenai"
    )

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(&googlegenai.GoogleAI{}),
        )
        if err != nil {
            log.Fatal(err)
        }

        r := gin.Default()

        // CORS for React frontend
        r.Use(cors.New(cors.Config{
            AllowOrigins:     []string{"http://localhost:3000"},
            AllowMethods:     []string{"POST", "GET", "OPTIONS"},
            AllowHeaders:     []string{"Content-Type", "Authorization"},
            AllowCredentials: true,
        }))

        // API routes
        r.POST("/api/flows/menuSuggestion", handleMenuSuggestion)

        r.Run(":8080")
    }
    ```

    ### Frontend Setup (React)

    ```bash
    cd frontend
    npx create-next-app@latest . --typescript
    npm install
    ```

</LanguageContent>

<LanguageContent lang="python">
For Python applications, create a FastAPI backend with React frontend:

    ### Backend Setup (Python)

    ```bash
    mkdir my-genkit-app
    cd my-genkit-app
    mkdir backend frontend

    cd backend
    pip install fastapi uvicorn genkit-plugin-google-genai
    ```

    ```python
    # backend/main.py
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from genkit.ai import Genkit
    from genkit.plugins.google_genai import GoogleGenai

    ai = Genkit(plugins=[GoogleGenai()])

    app = FastAPI()

    # CORS for React frontend
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:3000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    @app.post("/api/flows/menuSuggestion")
    async def menu_suggestion(request: dict):
        # Handle flow logic
        pass

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8080)
    ```

    ### Frontend Setup (React)

    ```bash
    cd ../frontend
    npx create-next-app@latest . --typescript
    npm install
    ```

</LanguageContent>

## Define Genkit Flows

<LanguageContent lang="js">
Create your Genkit flows in `src/genkit/flows.ts`:

    ```ts
    import { googleAI } from '@genkit-ai/googleai';
    import { genkit, z } from 'genkit';

    const ai = genkit({
      plugins: [googleAI()],
    });

    export const menuSuggestionFlow = ai.defineFlow(
      {
        name: 'menuSuggestionFlow',
        inputSchema: z.object({ theme: z.string() }),
        outputSchema: z.object({ menuItem: z.string() }),
        streamSchema: z.string(),
      },
      async ({ theme }, { sendChunk }) => {
        const { stream, response } = ai.generateStream({
          model: googleAI.model('gemini-2.5-flash'),
          prompt: `Invent a menu item for a ${theme} themed restaurant.`,
        });

        for await (const chunk of stream) {
          sendChunk(chunk.text);
        }

        const { text } = await response;
        return { menuItem: text };
      }
    );

    export const chatFlow = ai.defineFlow(
      {
        name: 'chatFlow',
        inputSchema: z.object({
          message: z.string(),
          history: z.array(z.object({
            role: z.enum(['user', 'assistant']),
            content: z.string(),
          })).optional(),
        }),
        outputSchema: z.object({ response: z.string() }),
        streamSchema: z.string(),
      },
      async ({ message, history = [] }, { sendChunk }) => {
        const conversationContext = history
          .map(msg => `${msg.role}: ${msg.content}`)
          .join('\n');

        const { stream, response } = ai.generateStream({
          model: googleAI.model('gemini-2.5-flash'),
          prompt: `${conversationContext}\nuser: ${message}\nassistant:`,
        });

        for await (const chunk of stream) {
          sendChunk(chunk.text);
        }

        const { text } = await response;
        return { response: text };
      }
    );
    ```

</LanguageContent>

<LanguageContent lang="go">
Define flows in your Go backend:

    ```go
    // backend/flows.go
    package main

    import (
        "context"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/ai"
    )

    type MenuSuggestionInput struct {
        Theme string `json:"theme"`
    }

    type MenuSuggestionOutput struct {
        MenuItem string `json:"menuItem"`
    }

    func handleMenuSuggestion(c *gin.Context) {
        var input MenuSuggestionInput
        if err := c.ShouldBindJSON(&input); err != nil {
            c.JSON(400, gin.H{"error": err.Error()})
            return
        }

        resp, err := genkit.Generate(ctx, g,
            ai.WithPrompt(fmt.Sprintf("Invent a menu item for a %s themed restaurant.", input.Theme)),
        )
        if err != nil {
            c.JSON(500, gin.H{"error": err.Error()})
            return
        }

        c.JSON(200, MenuSuggestionOutput{
            MenuItem: resp.Text(),
        })
    }

    type ChatInput struct {
        Message string `json:"message"`
        History []struct {
            Role    string `json:"role"`
            Content string `json:"content"`
        } `json:"history"`
    }

    type ChatOutput struct {
        Response string `json:"response"`
    }

    func handleChat(c *gin.Context) {
        var input ChatInput
        if err := c.ShouldBindJSON(&input); err != nil {
            c.JSON(400, gin.H{"error": err.Error()})
            return
        }

        // Build conversation context
        var context strings.Builder
        for _, msg := range input.History {
            context.WriteString(fmt.Sprintf("%s: %s\n", msg.Role, msg.Content))
        }
        context.WriteString(fmt.Sprintf("user: %s\nassistant:", input.Message))

        resp, err := genkit.Generate(ctx, g,
            ai.WithPrompt(context.String()),
        )
        if err != nil {
            c.JSON(500, gin.H{"error": err.Error()})
            return
        }

        c.JSON(200, ChatOutput{
            Response: resp.Text(),
        })
    }
    ```

</LanguageContent>

<LanguageContent lang="python">
Define flows in your Python backend:

    ```python
    # backend/flows.py
    from pydantic import BaseModel
    from typing import List, Optional

    class MenuSuggestionInput(BaseModel):
        theme: str

    class MenuSuggestionOutput(BaseModel):
        menuItem: str

    class ChatMessage(BaseModel):
        role: str
        content: str

    class ChatInput(BaseModel):
        message: str
        history: Optional[List[ChatMessage]] = []

    class ChatOutput(BaseModel):
        response: str

    @ai.define_flow(
        input_schema=MenuSuggestionInput,
        output_schema=MenuSuggestionOutput
    )
    async def menu_suggestion_flow(input_data: MenuSuggestionInput):
        response = await ai.generate(
            f"Invent a menu item for a {input_data.theme} themed restaurant."
        )
        return MenuSuggestionOutput(menuItem=response.text)

    @ai.define_flow(
        input_schema=ChatInput,
        output_schema=ChatOutput
    )
    async def chat_flow(input_data: ChatInput):
        # Build conversation context
        context = "\n".join([
            f"{msg.role}: {msg.content}"
            for msg in input_data.history
        ])
        context += f"\nuser: {input_data.message}\nassistant:"

        response = await ai.generate(context)
        return ChatOutput(response=response.text)
    ```

</LanguageContent>

## Create API Routes

<LanguageContent lang="js">
Create API routes using the Genkit Next.js plugin:

    ### Individual Route Files

    Create `src/app/api/menuSuggestion/route.ts`:

    ```ts
    import { menuSuggestionFlow } from '@/genkit/flows';
    import { appRoute } from '@genkit-ai/next';

    export const POST = appRoute(menuSuggestionFlow);
    ```

    Create `src/app/api/chat/route.ts`:

    ```ts
    import { chatFlow } from '@/genkit/flows';
    import { appRoute } from '@genkit-ai/next';

    export const POST = appRoute(chatFlow);
    ```

    ### Unified Route Handler

    Alternatively, create `src/app/api/flows/[flowName]/route.ts`:

    ```ts
    import { menuSuggestionFlow, chatFlow } from '@/genkit/flows';
    import { appRoute } from '@genkit-ai/next';

    const flows = {
      menuSuggestion: menuSuggestionFlow,
      chat: chatFlow,
    };

    export async function POST(
      request: Request,
      { params }: { params: { flowName: string } }
    ) {
      const flow = flows[params.flowName as keyof typeof flows];

      if (!flow) {
        return new Response('Flow not found', { status: 404 });
      }

      return appRoute(flow)(request);
    }
    ```

</LanguageContent>

<LanguageContent lang="go">
Set up API routes in your Gin router:

    ```go
    func setupRoutes(g *genkit.Genkit) *gin.Engine {
        r := gin.Default()

        // CORS middleware
        r.Use(cors.New(cors.Config{
            AllowOrigins:     []string{"http://localhost:3000"},
            AllowMethods:     []string{"POST", "GET", "OPTIONS"},
            AllowHeaders:     []string{"Content-Type", "Authorization"},
            AllowCredentials: true,
        }))

        // API routes
        api := r.Group("/api")
        {
            api.POST("/menuSuggestion", handleMenuSuggestion)
            api.POST("/chat", handleChat)
        }

        // Health check
        r.GET("/health", func(c *gin.Context) {
            c.JSON(200, gin.H{"status": "healthy"})
        })

        return r
    }
    ```

</LanguageContent>

<LanguageContent lang="python">
Set up API routes in FastAPI:

    ```python
    # backend/main.py
    @app.post("/api/menuSuggestion")
    async def menu_suggestion_endpoint(input_data: MenuSuggestionInput):
        result = await menu_suggestion_flow(input_data)
        return result

    @app.post("/api/chat")
    async def chat_endpoint(input_data: ChatInput):
        result = await chat_flow(input_data)
        return result

    @app.get("/health")
    async def health_check():
        return {"status": "healthy"}
    ```

</LanguageContent>

## Frontend Implementation

<LanguageContent lang="js">
Create your React components with Genkit integration:

    ### Basic Usage

    ```tsx
    // src/app/page.tsx
    'use client';

    import { useState } from 'react';
    import { runFlow, streamFlow } from '@genkit-ai/next/client';
    import { menuSuggestionFlow } from '@/genkit/flows';

    export default function Home() {
      const [menuItem, setMenuItem] = useState<string>('');
      const [isLoading, setIsLoading] = useState(false);
      const [streamedText, setStreamedText] = useState<string>('');

      async function getMenuItem(formData: FormData) {
        const theme = formData.get('theme')?.toString() ?? '';
        setIsLoading(true);

        try {
          const result = await runFlow<typeof menuSuggestionFlow>({
            url: '/api/menuSuggestion',
            input: { theme },
          });

          setMenuItem(result.menuItem);
        } catch (error) {
          console.error('Error generating menu item:', error);
        } finally {
          setIsLoading(false);
        }
      }

      async function streamMenuItem(formData: FormData) {
        const theme = formData.get('theme')?.toString() ?? '';
        setIsLoading(true);
        setStreamedText('');

        try {
          const result = streamFlow<typeof menuSuggestionFlow>({
            url: '/api/menuSuggestion',
            input: { theme },
          });

          for await (const chunk of result.stream) {
            setStreamedText((prev) => prev + chunk);
          }

          const finalOutput = await result.output;
          setMenuItem(finalOutput.menuItem);
        } catch (error) {
          console.error('Error streaming menu item:', error);
        } finally {
          setIsLoading(false);
        }
      }

      return (
        <main className="container mx-auto p-4">
          <h1 className="text-2xl font-bold mb-4">AI Menu Generator</h1>

          <form action={getMenuItem} className="space-y-4">
            <div>
              <label htmlFor="theme" className="block text-sm font-medium">
                Restaurant Theme:
              </label>
              <input
                type="text"
                name="theme"
                id="theme"
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                placeholder="e.g., medieval, space, underwater"
              />
            </div>

            <div className="space-x-2">
              <button
                type="submit"
                disabled={isLoading}
                className="bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50"
              >
                Generate
              </button>
              <button
                type="button"
                disabled={isLoading}
                onClick={(e) => {
                  e.preventDefault();
                  const formData = new FormData(e.currentTarget.form!);
                  streamMenuItem(formData);
                }}
                className="bg-green-500 text-white px-4 py-2 rounded disabled:opacity-50"
              >
                Stream Generation
              </button>
            </div>
          </form>

          {streamedText && (
            <div className="mt-4">
              <h3 className="text-lg font-semibold">Streaming Output:</h3>
              <pre className="bg-gray-100 p-4 rounded">{streamedText}</pre>
            </div>
          )}

          {menuItem && (
            <div className="mt-4">
              <h3 className="text-lg font-semibold">Final Output:</h3>
              <pre className="bg-gray-100 p-4 rounded">{menuItem}</pre>
            </div>
          )}
        </main>
      );
    }
    ```

    ### Chat Interface

    ```tsx
    // src/components/ChatInterface.tsx
    'use client';

    import { useState } from 'react';
    import { streamFlow } from '@genkit-ai/next/client';
    import { chatFlow } from '@/genkit/flows';

    interface Message {
      role: 'user' | 'assistant';
      content: string;
    }

    export default function ChatInterface() {
      const [messages, setMessages] = useState<Message[]>([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);

      async function sendMessage() {
        if (!input.trim()) return;

        const userMessage: Message = { role: 'user', content: input };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);

        try {
          const result = streamFlow<typeof chatFlow>({
            url: '/api/chat',
            input: {
              message: input,
              history: messages,
            },
          });

          let assistantMessage = '';
          setMessages(prev => [...prev, { role: 'assistant', content: '' }]);

          for await (const chunk of result.stream) {
            assistantMessage += chunk;
            setMessages(prev => [
              ...prev.slice(0, -1),
              { role: 'assistant', content: assistantMessage }
            ]);
          }

          const finalOutput = await result.output;
          setMessages(prev => [
            ...prev.slice(0, -1),
            { role: 'assistant', content: finalOutput.response }
          ]);
        } catch (error) {
          console.error('Error sending message:', error);
        } finally {
          setIsLoading(false);
        }
      }

      return (
        <div className="max-w-2xl mx-auto p-4">
          <div className="border rounded-lg h-96 overflow-y-auto p-4 mb-4">
            {messages.map((message, index) => (
              <div
                key={index}
                className={`mb-2 ${
                  message.role === 'user' ? 'text-right' : 'text-left'
                }`}
              >
                <div
                  className={`inline-block p-2 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 text-black'
                  }`}
                >
                  {message.content}
                </div>
              </div>
            ))}
          </div>

          <div className="flex space-x-2">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
              className="flex-1 border rounded-lg px-3 py-2"
              placeholder="Type your message..."
              disabled={isLoading}
            />
            <button
              onClick={sendMessage}
              disabled={isLoading || !input.trim()}
              className="bg-blue-500 text-white px-4 py-2 rounded-lg disabled:opacity-50"
            >
              Send
            </button>
          </div>
        </div>
      );
    }
    ```

</LanguageContent>

<LanguageContent lang="go">
Create React components that call your Go backend:

    ```tsx
    // frontend/src/app/page.tsx
    'use client';

    import { useState } from 'react';

    interface MenuSuggestionResponse {
      menuItem: string;
    }

    export default function Home() {
      const [menuItem, setMenuItem] = useState<string>('');
      const [isLoading, setIsLoading] = useState(false);

      async function getMenuItem(formData: FormData) {
        const theme = formData.get('theme')?.toString() ?? '';
        setIsLoading(true);

        try {
          const response = await fetch('http://localhost:8080/api/menuSuggestion', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ theme }),
          });

          if (!response.ok) {
            throw new Error('Failed to generate menu item');
          }

          const result: MenuSuggestionResponse = await response.json();
          setMenuItem(result.menuItem);
        } catch (error) {
          console.error('Error generating menu item:', error);
        } finally {
          setIsLoading(false);
        }
      }

      return (
        <main className="container mx-auto p-4">
          <h1 className="text-2xl font-bold mb-4">AI Menu Generator</h1>

          <form action={getMenuItem} className="space-y-4">
            <div>
              <label htmlFor="theme" className="block text-sm font-medium">
                Restaurant Theme:
              </label>
              <input
                type="text"
                name="theme"
                id="theme"
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                placeholder="e.g., medieval, space, underwater"
              />
            </div>

            <button
              type="submit"
              disabled={isLoading}
              className="bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50"
            >
              {isLoading ? 'Generating...' : 'Generate'}
            </button>
          </form>

          {menuItem && (
            <div className="mt-4">
              <h3 className="text-lg font-semibold">Generated Menu Item:</h3>
              <pre className="bg-gray-100 p-4 rounded">{menuItem}</pre>
            </div>
          )}
        </main>
      );
    }
    ```

</LanguageContent>

<LanguageContent lang="python">
Create React components that call your Python backend:

    ```tsx
    // frontend/src/app/page.tsx
    'use client';

    import { useState } from 'react';

    interface MenuSuggestionResponse {
      menuItem: string;
    }

    export default function Home() {
      const [menuItem, setMenuItem] = useState<string>('');
      const [isLoading, setIsLoading] = useState(false);

      async function getMenuItem(formData: FormData) {
        const theme = formData.get('theme')?.toString() ?? '';
        setIsLoading(true);

        try {
          const response = await fetch('http://localhost:8080/api/menuSuggestion', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ theme }),
          });

          if (!response.ok) {
            throw new Error('Failed to generate menu item');
          }

          const result: MenuSuggestionResponse = await response.json();
          setMenuItem(result.menuItem);
        } catch (error) {
          console.error('Error generating menu item:', error);
        } finally {
          setIsLoading(false);
        }
      }

      return (
        <main className="container mx-auto p-4">
          <h1 className="text-2xl font-bold mb-4">AI Menu Generator</h1>

          <form action={getMenuItem} className="space-y-4">
            <div>
              <label htmlFor="theme" className="block text-sm font-medium">
                Restaurant Theme:
              </label>
              <input
                type="text"
                name="theme"
                id="theme"
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                placeholder="e.g., medieval, space, underwater"
              />
            </div>

            <button
              type="submit"
              disabled={isLoading}
              className="bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50"
            >
              {isLoading ? 'Generating...' : 'Generate'}
            </button>
          </form>

          {menuItem && (
            <div className="mt-4">
              <h3 className="text-lg font-semibold">Generated Menu Item:</h3>
              <pre className="bg-gray-100 p-4 rounded">{menuItem}</pre>
            </div>
          )}
        </main>
      );
    }
    ```

</LanguageContent>

## Authentication and Security

<LanguageContent lang="js">
### API Key Authentication

    ```tsx
    // Client-side with headers
    const result = await runFlow<typeof menuSuggestionFlow>({
      url: '/api/menuSuggestion',
      headers: {
        Authorization: 'Bearer your-token-here',
      },
      input: { theme },
    });
    ```

    ### Next.js Middleware

    ```ts
    // middleware.ts
    import { NextRequest, NextResponse } from 'next/server';
    import { jwtVerify } from 'jose';

    export async function middleware(request: NextRequest) {
      if (request.nextUrl.pathname.startsWith('/api/')) {
        const token = request.headers.get('authorization')?.replace('Bearer ', '');

        if (!token) {
          return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        try {
          await jwtVerify(token, new TextEncoder().encode(process.env.JWT_SECRET!));
        } catch (error) {
          return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
        }
      }

      return NextResponse.next();
    }

    export const config = {
      matcher: '/api/:path*',
    };
    ```

    ### Session-based Authentication

    ```ts
    // src/app/api/auth/route.ts
    import { NextRequest, NextResponse } from 'next/server';
    import { cookies } from 'next/headers';

    export async function POST(request: NextRequest) {
      const { username, password } = await request.json();

      // Verify credentials
      if (await verifyCredentials(username, password)) {
        const sessionToken = generateSessionToken();

        cookies().set('session', sessionToken, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 60 * 60 * 24 * 7, // 1 week
        });

        return NextResponse.json({ success: true });
      }

      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 });
    }
    ```

</LanguageContent>

<LanguageContent lang="go">
Implement JWT authentication in your Go backend:

    ```go
    import (
        "github.com/golang-jwt/jwt/v4"
        "github.com/gin-gonic/gin"
    )

    func authMiddleware() gin.HandlerFunc {
        return func(c *gin.Context) {
            authHeader := c.GetHeader("Authorization")
            if authHeader == "" {
                c.JSON(401, gin.H{"error": "Missing authorization header"})
                c.Abort()
                return
            }

            tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

            token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
                return []byte(os.Getenv("JWT_SECRET")), nil
            })

            if err != nil || !token.Valid {
                c.JSON(401, gin.H{"error": "Invalid token"})
                c.Abort()
                return
            }

            c.Next()
        }
    }

    // Apply to protected routes
    api.POST("/menuSuggestion", authMiddleware(), handleMenuSuggestion)
    ```

</LanguageContent>

<LanguageContent lang="python">
Implement JWT authentication in your FastAPI backend:

    ```python
    from fastapi import Depends, HTTPException, status
    from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
    import jwt

    security = HTTPBearer()

    def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
        try:
            payload = jwt.decode(
                credentials.credentials,
                os.getenv("JWT_SECRET"),
                algorithms=["HS256"]
            )
            return payload
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )

    @app.post("/api/menuSuggestion")
    async def menu_suggestion_endpoint(
        input_data: MenuSuggestionInput,
        user=Depends(verify_token)
    ):
        result = await menu_suggestion_flow(input_data)
        return result
    ```

</LanguageContent>

## Deployment Considerations

### Environment Variables

<LanguageContent lang="js">
Configure environment variables for production:

    ```bash
    # .env.local
    GEMINI_API_KEY=your_gemini_api_key
    JWT_SECRET=your_jwt_secret
    NEXTAUTH_SECRET=your_nextauth_secret
    NEXTAUTH_URL=https://your-domain.com
    ```

    ### Vercel Deployment

    ```bash
    # Install Vercel CLI
    npm install -g vercel

    # Deploy
    vercel

    # Set environment variables
    vercel env add GEMINI_API_KEY
    vercel env add JWT_SECRET
    ```

    ### Docker Deployment

    ```dockerfile
    # Dockerfile
    FROM node:18-alpine

    WORKDIR /app

    COPY package*.json ./
    RUN npm ci --only=production

    COPY . .
    RUN npm run build

    EXPOSE 3000

    CMD ["npm", "start"]
    ```

</LanguageContent>

<LanguageContent lang="go">
Deploy your Go backend:

    ```dockerfile
    # Dockerfile
    FROM golang:1.21-alpine AS builder

    WORKDIR /app
    COPY go.mod go.sum ./
    RUN go mod download

    COPY . .
    RUN go build -o main .

    FROM alpine:latest
    RUN apk --no-cache add ca-certificates
    WORKDIR /root/

    COPY --from=builder /app/main .

    EXPOSE 8080

    CMD ["./main"]
    ```

    ### Cloud Run Deployment

    ```bash
    # Build and deploy
    gcloud builds submit --tag gcr.io/PROJECT_ID/genkit-backend
    gcloud run deploy --image gcr.io/PROJECT_ID/genkit-backend --platform managed
    ```

</LanguageContent>

<LanguageContent lang="python">
Deploy your Python backend:

    ```dockerfile
    # Dockerfile
    FROM python:3.11-slim

    WORKDIR /app

    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt

    COPY . .

    EXPOSE 8080

    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]
    ```

    ### Cloud Run Deployment

    ```bash
    # Build and deploy
    gcloud builds submit --tag gcr.io/PROJECT_ID/genkit-backend
    gcloud run deploy --image gcr.io/PROJECT_ID/genkit-backend --platform managed
    ```

</LanguageContent>

## Next Steps

- Learn about [creating flows](/docs/flows) to build more complex AI workflows
- Explore [authorization patterns](/docs/deployment/authorization) for securing your applications
- See [deployment guides](/docs/deployment) for production deployment strategies
- Check out other framework integrations:
  - [Express.js](/docs/frameworks/express) for API-first applications
