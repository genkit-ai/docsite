---
title: Error handling and types
description: Learn about error handling in Genkit, including specialized error types, best practices, and debugging techniques across JavaScript, Go, and Python.
---

import LanguageSelector from '../../../components/LanguageSelector.astro';
import CopyMarkdownButton from '../../../components/CopyMarkdownButton.astro';
import LanguageContent from '../../../components/LanguageContent.astro';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector />
  <CopyMarkdownButton />
</div>

Proper error handling is crucial for building robust AI applications. Genkit provides different error handling mechanisms and specialized error types across languages to help you build reliable and secure applications.

## Overview

Effective error handling in Genkit applications involves:

- **Specialized error types**: Different error types for different scenarios
- **Security considerations**: Preventing internal details from leaking to users
- **Proper error propagation**: Ensuring errors are handled at the right level
- **User-friendly messages**: Providing meaningful feedback to end users
- **Comprehensive error handling patterns**: Retry mechanisms, graceful degradation, and monitoring

## Availability and Approach

<LanguageContent lang="js">
JavaScript provides specialized error types and comprehensive error handling:
    - `GenkitError` for internal framework errors
    - `UserFacingError` for application-level errors
    - Automatic error sanitization in web hosting plugins
    - Built-in error tracing and debugging
    - Security-focused error handling
</LanguageContent>

<LanguageContent lang="go">
Go uses standard Go error handling patterns:
    - Standard `error` interface for all errors
    - Custom error types for specific scenarios
    - Error wrapping and unwrapping
    - Context-aware error handling
    - Structured error information
</LanguageContent>

<LanguageContent lang="python">
Python uses standard exception handling:
    - Built-in exception types
    - Custom exception classes
    - Try-catch error handling
    - Exception chaining and context
    - Framework-specific error handling
</LanguageContent>

## Specialized error types

<LanguageContent lang="js">
Genkit defines two main specialized error types that help you better understand where your error is coming from and how to handle it appropriately.

### GenkitError

`GenkitError` is intended for use by Genkit itself or Genkit plugins. These represent internal framework errors:

```typescript
import { GenkitError } from 'genkit';

// Example of a GenkitError (typically thrown by the framework)
throw new GenkitError({
  status: 'INVALID_ARGUMENT',
  message: 'Model configuration is invalid',
  details: { modelName: 'invalid-model' }
});
```

### UserFacingError

`UserFacingError` is intended for [`ContextProviders`](/docs/deployment/any-platform) and your application code. These represent application-level errors that can be safely shown to users:

```typescript
import { UserFacingError } from 'genkit';

const myFlow = ai.defineFlow({
  name: 'userFlow',
  inputSchema: z.object({ userId: z.string() }),
  outputSchema: z.string(),
}, async (input) => {
  const user = await getUserById(input.userId);
  
  if (!user) {
    throw new UserFacingError({
      status: 'NOT_FOUND',
      message: 'User not found',
    });
  }
  
  return `Hello, ${user.name}!`;
});
```

### Error sanitization

Genkit plugins for web hosting (e.g. [`@genkit-ai/express`](https://js.api.genkit.dev/modules/_genkit-ai_express.html) or [`@genkit-ai/next`](https://js.api.genkit.dev/modules/_genkit-ai_next.html)) SHOULD capture all other Error types and instead report them as an internal error in the response. This adds a layer of security to your application by ensuring that internal details of your application do not leak to attackers.

```typescript
// Internal errors are automatically sanitized
const myFlow = ai.defineFlow({
  name: 'secureFlow',
  inputSchema: z.string(),
  outputSchema: z.string(),
}, async (input) => {
  try {
    const result = await someInternalOperation(input);
    return result;
  } catch (error) {
    // This will be caught by the web hosting plugin
    // and converted to a generic "Internal Error" response
    throw new Error('Database connection failed: ' + sensitiveInfo);
  }
});
```

### Input validation example

```typescript
export const validateInput = ai.defineFlow(
  {
    name: 'validateInput',
    inputSchema: z.object({ text: z.string() }),
    outputSchema: z.object({ result: z.string() }),
  },
  async ({ text }) => {
    if (text.length > 1000) {
      throw new UserFacingError('Input text must be less than 1000 characters');
    }
    
    // Process the input...
    return { result: 'processed' };
  }
);
```
</LanguageContent>

<LanguageContent lang="go">
Go uses the standard error interface for all error handling. You can create custom error types for specific scenarios:

```go
import (
    "errors"
    "fmt"
)

// Custom error types
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error in field %s: %s", e.Field, e.Message)
}

type NotFoundError struct {
    Resource string
    ID       string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with ID %s not found", e.Resource, e.ID)
}

// Usage in flows
func myFlow(ctx context.Context, input FlowInput) (string, error) {
    if input.UserID == "" {
        return "", &ValidationError{
            Field:   "userID",
            Message: "userID is required",
        }
    }
    
    user, err := getUserByID(ctx, input.UserID)
    if err != nil {
        return "", fmt.Errorf("failed to get user: %w", err)
    }
    
    if user == nil {
        return "", &NotFoundError{
            Resource: "User",
            ID:       input.UserID,
        }
    }
    
    return fmt.Sprintf("Hello, %s!", user.Name), nil
}
```

### Error wrapping

Use error wrapping to preserve error context:

```go
func processData(ctx context.Context, data string) error {
    if err := validateData(data); err != nil {
        return fmt.Errorf("data validation failed: %w", err)
    }
    
    if err := saveData(ctx, data); err != nil {
        return fmt.Errorf("failed to save data: %w", err)
    }
    
    return nil
}

// Check for specific error types
func handleError(err error) {
    var validationErr *ValidationError
    if errors.As(err, &validationErr) {
        log.Printf("Validation error: %s", validationErr.Message)
        return
    }
    
    var notFoundErr *NotFoundError
    if errors.As(err, &notFoundErr) {
        log.Printf("Resource not found: %s", notFoundErr.Resource)
        return
    }
    
    log.Printf("Unknown error: %v", err)
}
```
</LanguageContent>

<LanguageContent lang="python">
Python uses standard exception handling with custom exception classes:

```python
from genkit.types import GenkitError

# Custom exception classes
class ValidationError(Exception):
    def __init__(self, field: str, message: str):
        self.field = field
        self.message = message
        super().__init__(f"Validation error in field {field}: {message}")

class NotFoundError(Exception):
    def __init__(self, resource: str, resource_id: str):
        self.resource = resource
        self.resource_id = resource_id
        super().__init__(f"{resource} with ID {resource_id} not found")

class UserFacingError(Exception):
    """Raised for errors that are safe to show to users."""
    pass

# Usage in flows
@ai.flow()
async def my_flow(input_data: dict, ctx):
    if not input_data.get('user_id'):
        raise ValidationError('user_id', 'user_id is required')
    
    try:
        user = await get_user_by_id(input_data['user_id'])
    except Exception as e:
        raise GenkitError(
            status='INTERNAL',
            message='Failed to retrieve user'
        ) from e
    
    if not user:
        raise NotFoundError('User', input_data['user_id'])
    
    return f"Hello, {user['name']}!"

# Error handling
try:
    result = await my_flow({'user_id': '123'}, ctx)
except ValidationError as e:
    print(f"Validation error: {e.message}")
except NotFoundError as e:
    print(f"Resource not found: {e.resource}")
except GenkitError as e:
    print(f"Genkit error: {e.message}")
except Exception as e:
    print(f"Unexpected error: {e}")
```
</LanguageContent>

## Error handling strategies

### Graceful degradation

Implement fallback mechanisms when AI operations fail:

<LanguageContent lang="js">
```typescript
export const robustFlow = ai.defineFlow(
  {
    name: 'robustFlow',
    inputSchema: z.object({ query: z.string() }),
    outputSchema: z.object({ response: z.string() }),
  },
  async ({ query }) => {
    try {
      // Try primary AI model
      const result = await ai.generate({
        model: googleAI.model('gemini-2.5-flash'),
        prompt: query,
      });
      return { response: result.text };
    } catch (error) {
      console.warn('Primary model failed, trying fallback:', error);
      
      try {
        // Fallback to simpler model
        const fallbackResult = await ai.generate({
          model: googleAI.model('gemini-1.5-flash'),
          prompt: query,
        });
        return { response: fallbackResult.text };
      } catch (fallbackError) {
        console.error('All models failed:', fallbackError);
        
        // Return default response
        return { 
          response: 'I apologize, but I cannot process your request at this time. Please try again later.' 
        };
      }
    }
  }
);
```
</LanguageContent>

<LanguageContent lang="go">
```go
func robustGeneration(ctx context.Context, g *genkit.Genkit, query string) (string, error) {
    // Try primary model
    resp, err := ai.Generate(ctx, g,
        ai.WithPrompt(query),
        ai.WithModel("googleai/gemini-2.5-flash"),
    )
    if err == nil {
        return resp.Text(), nil
    }
    
    log.Printf("Primary model failed, trying fallback: %v", err)
    
    // Try fallback model
    fallbackResp, fallbackErr := ai.Generate(ctx, g,
        ai.WithPrompt(query),
        ai.WithModel("googleai/gemini-1.5-flash"),
    )
    if fallbackErr == nil {
        return fallbackResp.Text(), nil
    }
    
    log.Printf("All models failed: %v", fallbackErr)
    
    // Return default response
    return "I apologize, but I cannot process your request at this time. Please try again later.", nil
}
```
</LanguageContent>

<LanguageContent lang="python">
```python
@ai.flow()
async def robust_generation(query: str) -> str:
    try:
        # Try primary model
        response = await ai.generate(
            prompt=query,
            model="googleai/gemini-2.5-flash"
        )
        return response.text
    except Exception as e:
        print(f"Primary model failed, trying fallback: {e}")
        
        try:
            # Try fallback model
            fallback_response = await ai.generate(
                prompt=query,
                model="googleai/gemini-1.5-flash"
            )
            return fallback_response.text
        except Exception as fallback_error:
            print(f"All models failed: {fallback_error}")
            
            # Return default response
            return "I apologize, but I cannot process your request at this time. Please try again later."
```
</LanguageContent>

### Retry mechanisms

Implement exponential backoff for transient failures:

<LanguageContent lang="js">
```typescript
async function generateWithRetry(
  prompt: string, 
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<string> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await ai.generate({
        model: googleAI.model('gemini-2.5-flash'),
        prompt,
      });
      return result.text;
    } catch (error) {
      if (attempt === maxRetries) {
        throw new UserFacingError('Service temporarily unavailable. Please try again later.');
      }
      
      // Exponential backoff
      const delay = baseDelay * Math.pow(2, attempt - 1);
      console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, error);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw new Error('Max retries exceeded');
}
```
</LanguageContent>

<LanguageContent lang="go">
```go
import (
    "time"
    "math"
)

func generateWithRetry(ctx context.Context, g *genkit.Genkit, prompt string, maxRetries int) (string, error) {
    baseDelay := time.Second
    
    for attempt := 1; attempt <= maxRetries; attempt++ {
        resp, err := ai.Generate(ctx, g,
            ai.WithPrompt(prompt),
            ai.WithModel("googleai/gemini-2.5-flash"),
        )
        if err == nil {
            return resp.Text(), nil
        }
        
        if attempt == maxRetries {
            return "", errors.New("service temporarily unavailable, please try again later")
        }
        
        // Exponential backoff
        delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt-1)))
        log.Printf("Attempt %d failed, retrying in %v: %v", attempt, delay, err)
        
        select {
        case <-ctx.Done():
            return "", ctx.Err()
        case <-time.After(delay):
            // Continue to next attempt
        }
    }
    
    return "", errors.New("max retries exceeded")
}
```
</LanguageContent>

<LanguageContent lang="python">
```python
import asyncio
import math

async def generate_with_retry(prompt: str, max_retries: int = 3, base_delay: float = 1.0) -> str:
    for attempt in range(1, max_retries + 1):
        try:
            response = await ai.generate(
                prompt=prompt,
                model="googleai/gemini-2.5-flash"
            )
            return response.text
        except Exception as error:
            if attempt == max_retries:
                raise UserFacingError("Service temporarily unavailable. Please try again later.")
            
            # Exponential backoff
            delay = base_delay * (2 ** (attempt - 1))
            print(f"Attempt {attempt} failed, retrying in {delay}s: {error}")
            await asyncio.sleep(delay)
    
    raise Exception("Max retries exceeded")
```
</LanguageContent>

## Error handling in flows

<LanguageContent lang="js">
Implement comprehensive error handling in your flows:

```typescript
const robustFlow = ai.defineFlow({
  name: 'robustFlow',
  inputSchema: z.object({
    text: z.string(),
    options: z.object({
      maxRetries: z.number().default(3),
    }).optional(),
  }),
  outputSchema: z.string(),
}, async (input, { logger }) => {
  const maxRetries = input.options?.maxRetries ?? 3;
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      logger.info(`Attempt ${attempt} of ${maxRetries}`);
      
      const result = await ai.generate({
        prompt: `Process this text: ${input.text}`,
      });
      
      if (!result.text) {
        throw new UserFacingError({
          status: 'FAILED_PRECONDITION',
          message: 'Generated content is empty',
        });
      }
      
      return result.text;
    } catch (error) {
      lastError = error as Error;
      logger.warn(`Attempt ${attempt} failed:`, { error: error.message });
      
      // Don't retry for user-facing errors
      if (error instanceof UserFacingError) {
        throw error;
      }
      
      // Wait before retrying (exponential backoff)
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
  }
  
  // All retries failed
  throw new UserFacingError({
    status: 'DEADLINE_EXCEEDED',
    message: 'Operation failed after multiple attempts',
    details: { attempts: maxRetries, lastError: lastError?.message },
  });
});
```
</LanguageContent>

<LanguageContent lang="go">
Implement robust error handling with retries and proper error classification:

```go
func robustFlow(ctx context.Context, input FlowInput) (string, error) {
    maxRetries := 3
    if input.Options != nil && input.Options.MaxRetries > 0 {
        maxRetries = input.Options.MaxRetries
    }
    
    var lastErr error
    
    for attempt := 1; attempt <= maxRetries; attempt++ {
        log.Printf("Attempt %d of %d", attempt, maxRetries)
        
        resp, err := genkit.Generate(ctx, g,
            ai.WithPrompt("Process this text: " + input.Text),
        )
        
        if err != nil {
            lastErr = err
            log.Printf("Attempt %d failed: %v", attempt, err)
            
            // Check if it's a permanent error (don't retry)
            var validationErr *ValidationError
            if errors.As(err, &validationErr) {
                return "", err // Don't retry validation errors
            }
            
            // Wait before retrying (exponential backoff)
            if attempt < maxRetries {
                backoff := time.Duration(math.Pow(2, float64(attempt))) * time.Second
                select {
                case <-time.After(backoff):
                    continue
                case <-ctx.Done():
                    return "", ctx.Err()
                }
            }
            continue
        }
        
        if resp.Text() == "" {
            return "", &ValidationError{
                Field:   "output",
                Message: "generated content is empty",
            }
        }
        
        return resp.Text(), nil
    }
    
    return "", fmt.Errorf("operation failed after %d attempts, last error: %w", maxRetries, lastErr)
}
```
</LanguageContent>

<LanguageContent lang="python">
Implement comprehensive error handling with retries:

```python
import asyncio
from typing import Optional

@ai.flow()
async def robust_flow(input_data: dict, ctx):
    text = input_data.get('text', '')
    max_retries = input_data.get('options', {}).get('max_retries', 3)
    
    last_error = None
    
    for attempt in range(1, max_retries + 1):
        try:
            logger.info(f"Attempt {attempt} of {max_retries}")
            
            result = await ai.generate(
                prompt=f"Process this text: {text}",
            )
            
            if not result.text:
                raise ValidationError('output', 'generated content is empty')
            
            return result.text
            
        except ValidationError:
            # Don't retry validation errors
            raise
        except Exception as e:
            last_error = e
            logger.warning(f"Attempt {attempt} failed: {e}")
            
            # Wait before retrying (exponential backoff)
            if attempt < max_retries:
                backoff = 2 ** attempt
                await asyncio.sleep(backoff)
    
    # All retries failed
    raise GenkitError(
        status='DEADLINE_EXCEEDED',
        message=f'Operation failed after {max_retries} attempts',
        details={'last_error': str(last_error)}
    )
```
</LanguageContent>

## Error handling in tools

<LanguageContent lang="js">
Tools should handle errors gracefully and provide meaningful feedback:

```typescript
const databaseTool = ai.defineTool({
  name: 'databaseQuery',
  description: 'Query the database for information',
  inputSchema: z.object({
    query: z.string(),
    table: z.string(),
  }),
  outputSchema: z.array(z.record(z.any())),
}, async (input, { logger }) => {
  try {
    // Validate input
    if (!input.query.trim()) {
      throw new UserFacingError({
        status: 'INVALID_ARGUMENT',
        message: 'Query cannot be empty',
      });
    }
    
    // Execute query
    const results = await database.query(input.query, input.table);
    
    logger.info('Database query executed successfully', {
      table: input.table,
      resultCount: results.length,
    });
    
    return results;
  } catch (error) {
    if (error instanceof UserFacingError) {
      throw error;
    }
    
    // Log internal errors but don't expose details
    logger.error('Database query failed', { 
      error: error.message,
      table: input.table 
    });
    
    throw new UserFacingError({
      status: 'INTERNAL',
      message: 'Database query failed',
    });
  }
});
```
</LanguageContent>

<LanguageContent lang="go">
Implement proper error handling in tools:

```go
func databaseQueryTool(ctx context.Context, input DatabaseQueryInput) ([]map[string]interface{}, error) {
    // Validate input
    if strings.TrimSpace(input.Query) == "" {
        return nil, &ValidationError{
            Field:   "query",
            Message: "query cannot be empty",
        }
    }
    
    // Execute query
    results, err := database.Query(ctx, input.Query, input.Table)
    if err != nil {
        log.Printf("Database query failed: %v", err)
        
        // Check for specific database errors
        if isDatabaseConnectionError(err) {
            return nil, fmt.Errorf("database connection failed: %w", err)
        }
        
        if isDatabaseTimeoutError(err) {
            return nil, fmt.Errorf("database query timeout: %w", err)
        }
        
        // Generic database error
        return nil, fmt.Errorf("database query failed: %w", err)
    }
    
    log.Printf("Database query executed successfully, returned %d results", len(results))
    return results, nil
}

// Helper functions to classify database errors
func isDatabaseConnectionError(err error) bool {
    // Implementation depends on your database driver
    return strings.Contains(err.Error(), "connection")
}

func isDatabaseTimeoutError(err error) bool {
    // Implementation depends on your database driver
    return strings.Contains(err.Error(), "timeout")
}
```
</LanguageContent>

<LanguageContent lang="python">
Implement comprehensive error handling in tools:

```python
@ai.tool()
def database_query_tool(input_data: dict, ctx) -> list:
    """Query the database for information"""
    
    query = input_data.get('query', '').strip()
    table = input_data.get('table', '')
    
    # Validate input
    if not query:
        raise ValidationError('query', 'query cannot be empty')
    
    if not table:
        raise ValidationError('table', 'table name is required')
    
    try:
        # Execute query
        results = database.query(query, table)
        
        logger.info(f"Database query executed successfully, returned {len(results)} results")
        return results
        
    except DatabaseConnectionError as e:
        logger.error(f"Database connection failed: {e}")
        raise GenkitError(
            status='UNAVAILABLE',
            message='Database connection failed'
        )
    except DatabaseTimeoutError as e:
        logger.error(f"Database query timeout: {e}")
        raise GenkitError(
            status='DEADLINE_EXCEEDED',
            message='Database query timeout'
        )
    except Exception as e:
        logger.error(f"Database query failed: {e}")
        raise GenkitError(
            status='INTERNAL',
            message='Database query failed'
        )
```
</LanguageContent>

## Error monitoring and logging

### Structured logging

<LanguageContent lang="js">
```typescript
import { logger } from 'genkit/logging';

export const monitoredFlow = ai.defineFlow(
  {
    name: 'monitoredFlow',
    inputSchema: z.object({ input: z.string() }),
    outputSchema: z.object({ output: z.string() }),
  },
  async ({ input }) => {
    const startTime = Date.now();
    
    try {
      logger.info('Flow execution started', { 
        flowName: 'monitoredFlow',
        inputLength: input.length,
        timestamp: new Date().toISOString()
      });
      
      const result = await ai.generate({
        model: googleAI.model('gemini-2.5-flash'),
        prompt: input,
      });
      
      const duration = Date.now() - startTime;
      logger.info('Flow execution completed', {
        flowName: 'monitoredFlow',
        duration,
        outputLength: result.text.length
      });
      
      return { output: result.text };
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error('Flow execution failed', {
        flowName: 'monitoredFlow',
        duration,
        error: error.message,
        stack: error.stack
      });
      
      throw error;
    }
  }
);
```
</LanguageContent>

<LanguageContent lang="go">
```go
import (
    "log/slog"
    "time"
)

func monitoredGeneration(ctx context.Context, g *genkit.Genkit, input string) (string, error) {
    startTime := time.Now()
    
    slog.InfoContext(ctx, "Generation started",
        "inputLength", len(input),
        "timestamp", startTime,
    )
    
    resp, err := ai.Generate(ctx, g,
        ai.WithPrompt(input),
        ai.WithModel("googleai/gemini-2.5-flash"),
    )
    
    duration := time.Since(startTime)
    
    if err != nil {
        slog.ErrorContext(ctx, "Generation failed",
            "duration", duration,
            "error", err.Error(),
        )
        return "", err
    }
    
    slog.InfoContext(ctx, "Generation completed",
        "duration", duration,
        "outputLength", len(resp.Text()),
    )
    
    return resp.Text(), nil
}
```
</LanguageContent>

<LanguageContent lang="python">
```python
import logging
import time
from typing import Dict, Any

logger = logging.getLogger(__name__)

@ai.flow()
async def monitored_generation(input_text: str) -> str:
    start_time = time.time()
    
    logger.info("Generation started", extra={
        "input_length": len(input_text),
        "timestamp": time.time()
    })
    
    try:
        response = await ai.generate(
            prompt=input_text,
            model="googleai/gemini-2.5-flash"
        )
        
        duration = time.time() - start_time
        logger.info("Generation completed", extra={
            "duration": duration,
            "output_length": len(response.text)
        })
        
        return response.text
    except Exception as error:
        duration = time.time() - start_time
        logger.error("Generation failed", extra={
            "duration": duration,
            "error": str(error)
        })
        raise
```
</LanguageContent>

## Best practices

### Error classification

<LanguageContent lang="js">
- Use `UserFacingError` for errors that can be safely shown to users
    - Use `GenkitError` for internal framework errors
    - Let other errors be automatically sanitized by web hosting plugins
    - Provide meaningful error messages and status codes
    - Include relevant context in error details
</LanguageContent>

<LanguageContent lang="go">
- Create custom error types for different error categories
    - Use error wrapping to preserve error context
    - Implement error classification functions
    - Provide structured error information
    - Use appropriate logging levels for different error types
</LanguageContent>

<LanguageContent lang="python">
- Create custom exception classes for different error types
    - Use exception chaining to preserve error context
    - Implement proper exception handling hierarchies
    - Provide meaningful error messages
    - Use structured logging for error information
</LanguageContent>

### Security considerations

<LanguageContent lang="js">
- Never expose internal system details in user-facing errors
    - Use error sanitization in production environments
    - Log detailed error information for debugging
    - Implement rate limiting for error-prone operations
    - Validate all inputs to prevent injection attacks
</LanguageContent>

<LanguageContent lang="go">
- Sanitize error messages before returning to clients
    - Use structured logging to separate internal and external error details
    - Implement proper input validation
    - Use context timeouts to prevent resource exhaustion
    - Implement circuit breakers for external dependencies
</LanguageContent>

<LanguageContent lang="python">
- Sanitize exception messages in production
    - Use different exception types for internal vs external errors
    - Implement proper input validation and sanitization
    - Use async timeouts for long-running operations
    - Implement retry logic with exponential backoff
</LanguageContent>

### Error message guidelines

1. **Be helpful**: Provide actionable guidance when possible
2. **Be specific**: Give enough detail to understand the problem
3. **Be consistent**: Use consistent error message formats
4. **Be secure**: Don't reveal internal system details

### Testing error scenarios

<LanguageContent lang="js">
```typescript
// Test error handling
describe('Flow error handling', () => {
  it('should handle invalid input gracefully', async () => {
    const result = await expect(
      validateInput({ text: 'x'.repeat(1001) })
    ).rejects.toThrow(UserFacingError);
  });
  
  it('should retry on transient failures', async () => {
    // Mock transient failure
    const mockGenerate = jest.fn()
      .mockRejectedValueOnce(new Error('Temporary failure'))
      .mockResolvedValueOnce({ text: 'Success' });
    
    const result = await generateWithRetry('test prompt');
    expect(result).toBe('Success');
    expect(mockGenerate).toHaveBeenCalledTimes(2);
  });
});
```
</LanguageContent>

### Debugging and monitoring

<LanguageContent lang="js">
- Use the Developer UI to inspect error traces
    - Implement comprehensive logging with error context
    - Set up error monitoring and alerting
    - Use error tracking services for production
    - Include correlation IDs for distributed tracing
</LanguageContent>

<LanguageContent lang="go">
- Use structured logging for better error analysis
    - Implement error metrics and monitoring
    - Use distributed tracing for complex workflows
    - Set up alerting for error rate thresholds
    - Include request IDs for error correlation
</LanguageContent>

<LanguageContent lang="python">
- Use structured logging for error analysis
    - Implement error tracking and monitoring
    - Use APM tools for error insights
    - Set up alerting for error patterns
    - Include trace IDs for error correlation
</LanguageContent>

## Next steps

- Learn about [observability and monitoring](/docs/observability-monitoring) for tracking and debugging errors
- Explore [developer tools](/docs/devtools) for debugging error scenarios
- See [creating flows](/docs/flows) for implementing robust error handling in workflows
- Check out [tool calling](/docs/tool-calling) for error handling in tool implementations
