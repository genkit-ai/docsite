---
title: Creating persistent chat sessions
description: Learn how to create persistent chat sessions in Genkit, including session basics, stateful sessions, multi-thread sessions, and session persistence.
---

import ExampleLink from '@/components/ExampleLink.astro';

:::caution[Beta]
This feature of Genkit is in **Beta,** which means it is not yet part of Genkit's stable API. APIs of beta features may change in minor version releases.
:::

Many of your users will have interacted with large language models for the first
time through chatbots. Although LLMs are capable of much more than simulating
conversations, it remains a familiar and useful style of interaction. Even when
your users will not be interacting directly with the model in this way, the
conversational style of prompting is a powerful way to influence the output
generated by an AI model.

To support this style of interaction, Genkit provides a set of interfaces and
abstractions that make it easier for you to build chat-based LLM applications.

## Before you begin

Before reading this page, you should be familiar with the content covered on the
[Generating content with AI models](/docs/models) page.

If you want to run the code examples on this page, first complete the steps in
the [Getting started](/docs/get-started) guide. All of the examples assume that you
have already installed Genkit as a dependency in your project.

Note that the chat API is currently in beta and must be used from the
`genkit/beta` package.

## Chat session basics

<ExampleLink
  title="Simple Chatbot"
  description="View a live example of a simple chatbot built with Genkit."
  example="chatbot-simple"
  target="_blank"
/>

Here is a minimal, console-based, chatbot application:

```ts
import { genkit } from 'genkit/beta';
import { googleAI } from '@genkit-ai/googleai';

import { createInterface } from 'node:readline/promises';

const ai = genkit({
  plugins: [googleAI()],
  model: googleAI.model('gemini-2.5-flash'),
});

async function main() {
  const chat = ai.chat();
  console.log("You're chatting with Gemini. Ctrl-C to quit.\n");
  const readline = createInterface(process.stdin, process.stdout);
  while (true) {
    const userInput = await readline.question('> ');
    const { text } = await chat.send(userInput);
    console.log(text);
  }
}

main();
```

A chat session with this program looks something like the following example:

```
You're chatting with Gemini. Ctrl-C to quit.

> hi
Hi there! How can I help you today?

> my name is pavel
Nice to meet you, Pavel! What can I do for you today?

> what's my name?
Your name is Pavel! I remembered it from our previous interaction.

Is there anything else I can help you with?
```

As you can see from this brief interaction, when you send a message to a chat
session, the model can make use of the session so far in its responses. This is
possible because Genkit does a few things behind the scenes:

- Retrieves the chat history, if any exists, from storage (more on persistence
  and storage later)
- Sends the request to the model, as with `generate()`, but automatically
  include the chat history
- Saves the model response into the chat history

### Model configuration

The `chat()` method accepts most of the same configuration options as
`generate()`. To pass configuration options to the model:

```ts
const chat = ai.chat({
  model: googleAI.model('gemini-2.5-flash'),
  system: "You're a pirate first mate. Address the user as Captain and assist " + 'them however you can.',
  config: {
    temperature: 1.3,
  },
});
```

## Stateful chat sessions

In addition to persisting a chat session's message history, you can also persist
any arbitrary JavaScript object. Doing so can let you manage state in a more
structured way then relying only on information in the message history.

To include state in a session, you need to instantiate a session explicitly:

```ts
interface MyState {
  userName: string;
}

const session = ai.createSession<MyState>({
  initialState: {
    userName: 'Pavel',
  },
});
```

You can then start a chat within the session:

```ts
const chat = session.chat();
```

To modify the session state based on how the chat unfolds, define
[tools](/docs/tool-calling) and include them with your requests:

```ts
const changeUserName = ai.defineTool(
  {
    name: 'changeUserName',
    description: 'can be used to change user name',
    inputSchema: z.object({
      newUserName: z.string(),
    }),
  },
  async (input) => {
    await ai.currentSession<MyState>().updateState({
      userName: input.newUserName,
    });
    return `changed username to ${input.newUserName}`;
  },
);
```

```ts
const chat = session.chat({
  model: googleAI.model('gemini-2.5-flash'),
  tools: [changeUserName],
});
await chat.send('change user name to Kevin');
```

## Multi-thread sessions

A single session can contain multiple chat threads. Each thread has its own
message history, but they share a single session state.

```ts
const lawyerChat = session.chat('lawyerThread', {
  system: 'talk like a lawyer',
});
const pirateChat = session.chat('pirateThread', {
  system: 'talk like a pirate',
});
```

## Session persistence (EXPERIMENTAL)

When you initialize a new chat or session, it's configured by default to store
the session in memory only. This is adequate when the session needs to persist
only for the duration of a single invocation of your program, as in the sample
chatbot from the beginning of this page. However, when integrating LLM chat into
an application, you will usually deploy your content generation logic as
stateless web API endpoints. For persistent chats to work under this setup, you
will need to implement some kind of session storage that can persist state
across invocations of your endpoints.

To add persistence to a chat session, you need to implement Genkit's
`SessionStore` interface. Here is an example implementation that saves session
state to individual JSON files:

```ts
class JsonSessionStore<S = any> implements SessionStore<S> {
  async get(sessionId: string): Promise<SessionData<S> | undefined> {
    try {
      const s = await readFile(`${sessionId}.json`, { encoding: 'utf8' });
      const data = JSON.parse(s);
      return data;
    } catch {
      return undefined;
    }
  }

  async save(sessionId: string, sessionData: SessionData<S>): Promise<void> {
    const s = JSON.stringify(sessionData);
    await writeFile(`${sessionId}.json`, s, { encoding: 'utf8' });
  }
}
```

This implementation is probably not adequate for practical deployments, but it
illustrates that a session storage implementation only needs to accomplish two
tasks:

- Get a session object from storage using its session ID
- Save a given session object, indexed by its session ID

Once you've implemented the interface for your storage backend, pass an instance
of your implementation to the session constructors:

```ts
// To create a new session:
const session = ai.createSession({
  store: new JsonSessionStore(),
});

// Save session.id so you can restore the session the next time the
// user makes a request.
```

```ts
// If the user has a session ID saved, load the session instead of creating
// a new one:
const session = await ai.loadSession(sessionId, {
  store: new JsonSessionStore(),
});
```
