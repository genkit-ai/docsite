---
title: Deploy to Any Platform
description: Learn how to deploy Genkit flows to any Node.js, Go, or Python hosting platform with maximum flexibility and control.
---

import LanguageSelector from '../../../../components/LanguageSelector.astro';
import CopyMarkdownButton from '../../../../components/CopyMarkdownButton.astro';
import LanguageContent from '../../../../components/LanguageContent.astro';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector />
  <CopyMarkdownButton />
</div>

Genkit flows can be deployed to any platform that supports Node.js, Go, or Python applications. This approach gives you maximum flexibility and control over your deployment environment, allowing you to choose the hosting provider that best fits your needs.

## Key Features

- **Platform agnostic**: Deploy to any hosting provider
- **Full control**: Complete control over infrastructure and configuration
- **Cost flexibility**: Choose the most cost-effective hosting option
- **Custom environments**: Support for specialized deployment requirements
- **Hybrid deployments**: Mix and match different platforms for different services

## Prerequisites

- Hosting platform that supports your chosen language runtime
- Basic understanding of web server deployment
- Familiarity with [Genkit flows](/docs/flows)

## Popular Hosting Platforms

### Node.js Platforms
- **Vercel**: Excellent for Next.js and serverless functions
- **Netlify**: Great for JAMstack applications
- **Railway**: Simple deployment with automatic scaling
- **Render**: Easy deployment with managed databases
- **DigitalOcean App Platform**: Managed platform with predictable pricing
- **AWS Lambda**: Serverless with pay-per-request pricing
- **Heroku**: Simple deployment with add-on ecosystem

### Go Platforms
- **Railway**: Native Go support with simple deployment
- **Render**: Managed Go hosting with auto-scaling
- **DigitalOcean App Platform**: Container-based Go deployment
- **AWS Lambda**: Serverless Go functions
- **Fly.io**: Global edge deployment
- **PlanetScale**: For Go applications with database needs

### Python Platforms
- **Railway**: Python support with automatic dependency detection
- **Render**: Managed Python hosting
- **PythonAnywhere**: Python-focused hosting platform
- **DigitalOcean App Platform**: Container-based Python deployment
- **AWS Lambda**: Serverless Python functions
- **Heroku**: Traditional Python hosting

## Implementation

### Basic Server Setup

<LanguageContent lang="js">
Create a production-ready Express server:

    ```ts
    import { genkit, z } from 'genkit';
    import { googleAI } from '@genkit-ai/googleai';
    import { startFlowServer } from '@genkit-ai/express';
    import express from 'express';
    import helmet from 'helmet';
    import rateLimit from 'express-rate-limit';

    const ai = genkit({
      plugins: [googleAI()],
      model: googleAI.model('gemini-2.5-flash'),
    });

    // Define your flows
    const chatFlow = ai.defineFlow(
      {
        name: 'chat',
        inputSchema: z.object({ 
          message: z.string(),
          history: z.array(z.object({
            role: z.enum(['user', 'assistant']),
            content: z.string()
          })).optional()
        }),
        outputSchema: z.object({ response: z.string() }),
      },
      async ({ message, history = [] }) => {
        const context = history.map(h => `${h.role}: ${h.content}`).join('\n');
        const prompt = context ? `${context}\nuser: ${message}` : message;
        
        const { text } = await ai.generate(prompt);
        return { response: text };
      }
    );

    // Create Express app with security middleware
    const app = express();

    // Security middleware
    app.use(helmet());
    app.use(express.json({ limit: '10mb' }));

    // Rate limiting
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // limit each IP to 100 requests per windowMs
      message: 'Too many requests from this IP, please try again later.'
    });
    app.use('/api/', limiter);

    // Health check endpoint
    app.get('/health', (req, res) => {
      res.status(200).json({ status: 'healthy', timestamp: new Date().toISOString() });
    });

    // Start flow server with custom Express app
    startFlowServer({
      flows: [chatFlow],
      port: parseInt(process.env.PORT || '3000'),
      app, // Use custom Express app
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        credentials: true,
      },
    });

    console.log(`Server running on port ${process.env.PORT || 3000}`);
    ```

    **Package.json for deployment**:
    ```json
    {
      "name": "genkit-app",
      "version": "1.0.0",
      "scripts": {
        "build": "tsc",
        "start": "node dist/index.js",
        "dev": "tsx src/index.ts",
        "postinstall": "npm run build"
      },
      "dependencies": {
        "genkit": "^0.5.0",
        "@genkit-ai/googleai": "^0.5.0",
        "@genkit-ai/express": "^0.5.0",
        "express": "^4.18.0",
        "helmet": "^7.0.0",
        "express-rate-limit": "^6.7.0"
      },
      "devDependencies": {
        "typescript": "^5.0.0",
        "tsx": "^4.0.0",
        "@types/express": "^4.17.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    }
    ```
</LanguageContent>

<LanguageContent lang="go">
Create a production-ready Go server:

    ```go
    package main

    import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "strconv"
        "time"

        "github.com/firebase/genkit/go/ai"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/googlegenai"
        "golang.org/x/time/rate"
    )

    type ChatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
    }

    type ChatInput struct {
        Message string        `json:"message"`
        History []ChatMessage `json:"history,omitempty"`
    }

    type ChatOutput struct {
        Response string `json:"response"`
    }

    type HealthResponse struct {
        Status    string `json:"status"`
        Timestamp string `json:"timestamp"`
    }

    // Rate limiting middleware
    func rateLimitMiddleware(limiter *rate.Limiter) func(http.Handler) http.Handler {
        return func(next http.Handler) http.Handler {
            return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                if !limiter.Allow() {
                    http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                    return
                }
                next.ServeHTTP(w, r)
            })
        }
    }

    // CORS middleware
    func corsMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Access-Control-Allow-Origin", "*")
            w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
            w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
            
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusOK)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }

    // Security headers middleware
    func securityMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("X-Content-Type-Options", "nosniff")
            w.Header().Set("X-Frame-Options", "DENY")
            w.Header().Set("X-XSS-Protection", "1; mode=block")
            next.ServeHTTP(w, r)
        })
    }

    func main() {
        ctx := context.Background()

        // Initialize Genkit
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(&googlegenai.GoogleAI{}),
            genkit.WithDefaultModel("googleai/gemini-2.5-flash"),
        )
        if err != nil {
            log.Fatalf("failed to initialize Genkit: %v", err)
        }

        // Define chat flow
        chatFlow := genkit.DefineFlow(g, "chat", 
            func(ctx context.Context, input ChatInput) (ChatOutput, error) {
                var context string
                for _, msg := range input.History {
                    context += fmt.Sprintf("%s: %s\n", msg.Role, msg.Content)
                }
                
                prompt := input.Message
                if context != "" {
                    prompt = context + "user: " + input.Message
                }

                resp, err := genkit.Generate(ctx, g, ai.WithPrompt(prompt))
                if err != nil {
                    return ChatOutput{}, fmt.Errorf("failed to generate response: %w", err)
                }

                return ChatOutput{Response: resp.Text()}, nil
            })

        // Create rate limiter (100 requests per minute)
        limiter := rate.NewLimiter(rate.Every(time.Minute/100), 100)

        // Set up HTTP routes
        mux := http.NewServeMux()

        // Health check endpoint
        mux.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now().Format(time.RFC3339),
            })
        })

        // Chat endpoint with middleware
        mux.Handle("POST /chat", 
            securityMiddleware(
                corsMiddleware(
                    rateLimitMiddleware(limiter)(
                        genkit.Handler(chatFlow)))))

        port := os.Getenv("PORT")
        if port == "" {
            port = "8080"
        }

        server := &http.Server{
            Addr:         ":" + port,
            Handler:      mux,
            ReadTimeout:  30 * time.Second,
            WriteTimeout: 30 * time.Second,
            IdleTimeout:  120 * time.Second,
        }

        log.Printf("Server starting on port %s", port)
        log.Fatal(server.ListenAndServe())
    }
    ```

    **go.mod for deployment**:
    ```go
    module genkit-app

    go 1.21

    require (
        github.com/firebase/genkit/go v0.5.0
        golang.org/x/time v0.5.0
    )
    ```
</LanguageContent>

<LanguageContent lang="python">
Create a production-ready Flask server:

    ```python
    import os
    import time
    from datetime import datetime
    from typing import List, Optional
    from flask import Flask, request, jsonify
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    from flask_cors import CORS

    from genkit.ai import Genkit
    from genkit.plugins.flask import genkit_flask_handler
    from genkit.plugins.google_genai import GoogleGenAI, google_genai_name
    from genkit.types import GenkitError

    # Initialize Genkit
    ai = Genkit(
        plugins=[GoogleGenAI()],
        model=google_genai_name('gemini-2.5-flash'),
    )

    # Create Flask app
    app = Flask(__name__)

    # Configure CORS
    CORS(app, origins=os.environ.get('ALLOWED_ORIGINS', 'http://localhost:3000').split(','))

    # Configure rate limiting
    limiter = Limiter(
        app,
        key_func=get_remote_address,
        default_limits=["100 per hour"]
    )

    # Security headers
    @app.after_request
    def add_security_headers(response):
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        return response

    # Data models
    class ChatMessage:
        def __init__(self, role: str, content: str):
            self.role = role
            self.content = content

    class ChatInput:
        def __init__(self, message: str, history: Optional[List[ChatMessage]] = None):
            self.message = message
            self.history = history or []

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat()
        })

    # Chat flow with rate limiting
    @app.post('/chat')
    @limiter.limit("10 per minute")
    @genkit_flask_handler(ai)
    @ai.flow()
    async def chat(data: dict, ctx):
        try:
            message = data.get('message', '')
            history = data.get('history', [])
            
            if not message:
                raise GenkitError(status='INVALID_ARGUMENT', message='Message is required')
            
            # Build context from history
            context = ''
            for msg in history:
                context += f"{msg.get('role', 'user')}: {msg.get('content', '')}\n"
            
            prompt = message
            if context:
                prompt = context + f"user: {message}"
            
            response = await ai.generate(
                on_chunk=ctx.send_chunk,
                prompt=prompt,
            )
            
            return {'response': response.text}
            
        except Exception as e:
            raise GenkitError(status='INTERNAL', message=str(e))

    # Error handlers
    @app.errorhandler(429)
    def ratelimit_handler(e):
        return jsonify({'error': 'Rate limit exceeded', 'message': str(e)}), 429

    @app.errorhandler(500)
    def internal_error(e):
        return jsonify({'error': 'Internal server error'}), 500

    if __name__ == "__main__":
        port = int(os.environ.get("PORT", 5000))
        debug = os.environ.get("FLASK_ENV") == "development"
        
        app.run(
            debug=debug,
            host="0.0.0.0",
            port=port,
            threaded=True
        )
    ```

    **requirements.txt for deployment**:
    ```txt
    genkit>=0.5.0
    genkit-plugin-google-genai>=0.5.0
    genkit-plugin-flask>=0.5.0
    flask>=2.3.0
    flask-limiter>=3.3.0
    flask-cors>=4.0.0
    gunicorn>=21.0.0
    ```

    **Procfile for platforms like Heroku**:
    ```
    web: gunicorn --bind 0.0.0.0:$PORT --workers 2 --threads 4 --timeout 120 app:app
    ```
</LanguageContent>

## Platform-Specific Deployment

### Vercel (Node.js)

<LanguageContent lang="js">
**vercel.json**:
    ```json
    {
      "version": 2,
      "builds": [
        {
          "src": "src/index.ts",
          "use": "@vercel/node"
        }
      ],
      "routes": [
        {
          "src": "/(.*)",
          "dest": "src/index.ts"
        }
      ],
      "env": {
        "GEMINI_API_KEY": "@gemini-api-key"
      }
    }
    ```

    **Deploy**:
    ```bash
    # Install Vercel CLI
    npm i -g vercel

    # Deploy
    vercel --prod
    ```
</LanguageContent>

### Railway

<LanguageContent lang="js">
**railway.json**:
    ```json
    {
      "$schema": "https://railway.app/railway.schema.json",
      "build": {
        "builder": "NIXPACKS"
      },
      "deploy": {
        "startCommand": "npm start",
        "healthcheckPath": "/health",
        "healthcheckTimeout": 100,
        "restartPolicyType": "ON_FAILURE",
        "restartPolicyMaxRetries": 10
      }
    }
    ```
</LanguageContent>

<LanguageContent lang="go">
**railway.json**:
    ```json
    {
      "$schema": "https://railway.app/railway.schema.json",
      "build": {
        "builder": "NIXPACKS"
      },
      "deploy": {
        "startCommand": "./main",
        "healthcheckPath": "/health",
        "healthcheckTimeout": 100,
        "restartPolicyType": "ON_FAILURE",
        "restartPolicyMaxRetries": 10
      }
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
**railway.json**:
    ```json
    {
      "$schema": "https://railway.app/railway.schema.json",
      "build": {
        "builder": "NIXPACKS"
      },
      "deploy": {
        "startCommand": "gunicorn --bind 0.0.0.0:$PORT app:app",
        "healthcheckPath": "/health",
        "healthcheckTimeout": 100,
        "restartPolicyType": "ON_FAILURE",
        "restartPolicyMaxRetries": 10
      }
    }
    ```
</LanguageContent>

### Render

<LanguageContent lang="js">
**render.yaml**:
    ```yaml
    services:
      - type: web
        name: genkit-app
        env: node
        buildCommand: npm install && npm run build
        startCommand: npm start
        healthCheckPath: /health
        envVars:
          - key: NODE_ENV
            value: production
          - key: GEMINI_API_KEY
            sync: false
    ```
</LanguageContent>

<LanguageContent lang="go">
**render.yaml**:
    ```yaml
    services:
      - type: web
        name: genkit-go-app
        env: go
        buildCommand: go build -o main .
        startCommand: ./main
        healthCheckPath: /health
        envVars:
          - key: GEMINI_API_KEY
            sync: false
    ```
</LanguageContent>

<LanguageContent lang="python">
**render.yaml**:
    ```yaml
    services:
      - type: web
        name: genkit-python-app
        env: python
        buildCommand: pip install -r requirements.txt
        startCommand: gunicorn --bind 0.0.0.0:$PORT app:app
        healthCheckPath: /health
        envVars:
          - key: FLASK_ENV
            value: production
          - key: GEMINI_API_KEY
            sync: false
    ```
</LanguageContent>

### DigitalOcean App Platform

<LanguageContent lang="js">
**.do/app.yaml**:
    ```yaml
    name: genkit-app
    services:
      - name: web
        source_dir: /
        github:
          repo: your-username/your-repo
          branch: main
        run_command: npm start
        environment_slug: node-js
        instance_count: 1
        instance_size_slug: basic-xxs
        health_check:
          http_path: /health
        envs:
          - key: NODE_ENV
            value: production
          - key: GEMINI_API_KEY
            value: ${GEMINI_API_KEY}
            type: SECRET
    ```
</LanguageContent>

<LanguageContent lang="go">
**.do/app.yaml**:
    ```yaml
    name: genkit-go-app
    services:
      - name: web
        source_dir: /
        github:
          repo: your-username/your-repo
          branch: main
        run_command: ./main
        environment_slug: go
        instance_count: 1
        instance_size_slug: basic-xxs
        health_check:
          http_path: /health
        envs:
          - key: GEMINI_API_KEY
            value: ${GEMINI_API_KEY}
            type: SECRET
    ```
</LanguageContent>

<LanguageContent lang="python">
**.do/app.yaml**:
    ```yaml
    name: genkit-python-app
    services:
      - name: web
        source_dir: /
        github:
          repo: your-username/your-repo
          branch: main
        run_command: gunicorn --bind 0.0.0.0:$PORT app:app
        environment_slug: python
        instance_count: 1
        instance_size_slug: basic-xxs
        health_check:
          http_path: /health
        envs:
          - key: FLASK_ENV
            value: production
          - key: GEMINI_API_KEY
            value: ${GEMINI_API_KEY}
            type: SECRET
    ```
</LanguageContent>

## Environment Configuration

### Environment Variables

<LanguageContent lang="js">
Create `.env.example`:
    ```bash
    # Required
    GEMINI_API_KEY=your_api_key_here
    PORT=3000

    # Optional
    NODE_ENV=production
    ALLOWED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com
    RATE_LIMIT_WINDOW_MS=900000
    RATE_LIMIT_MAX_REQUESTS=100
    ```

    **Environment validation**:
    ```ts
    import { z } from 'zod';

    const envSchema = z.object({
      GEMINI_API_KEY: z.string().min(1, 'GEMINI_API_KEY is required'),
      PORT: z.string().default('3000'),
      NODE_ENV: z.enum(['development', 'production']).default('development'),
      ALLOWED_ORIGINS: z.string().optional(),
    });

    export const env = envSchema.parse(process.env);
    ```
</LanguageContent>

<LanguageContent lang="go">
**Environment validation**:
    ```go
    package main

    import (
        "log"
        "os"
        "strconv"
    )

    type Config struct {
        GeminiAPIKey   string
        Port           string
        AllowedOrigins []string
        RateLimit      int
    }

    func loadConfig() Config {
        apiKey := os.Getenv("GEMINI_API_KEY")
        if apiKey == "" {
            log.Fatal("GEMINI_API_KEY environment variable is required")
        }

        port := os.Getenv("PORT")
        if port == "" {
            port = "8080"
        }

        rateLimitStr := os.Getenv("RATE_LIMIT")
        rateLimit := 100 // default
        if rateLimitStr != "" {
            if parsed, err := strconv.Atoi(rateLimitStr); err == nil {
                rateLimit = parsed
            }
        }

        return Config{
            GeminiAPIKey: apiKey,
            Port:         port,
            RateLimit:    rateLimit,
        }
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
**Environment validation**:
    ```python
    import os
    from typing import List

    class Config:
        def __init__(self):
            self.gemini_api_key = self._get_required_env('GEMINI_API_KEY')
            self.port = int(os.environ.get('PORT', 5000))
            self.flask_env = os.environ.get('FLASK_ENV', 'development')
            self.allowed_origins = self._get_list_env('ALLOWED_ORIGINS', ['http://localhost:3000'])
            self.rate_limit = int(os.environ.get('RATE_LIMIT', 100))

        def _get_required_env(self, key: str) -> str:
            value = os.environ.get(key)
            if not value:
                raise ValueError(f'{key} environment variable is required')
            return value

        def _get_list_env(self, key: str, default: List[str]) -> List[str]:
            value = os.environ.get(key)
            return value.split(',') if value else default

    config = Config()
    ```
</LanguageContent>

## Monitoring and Logging

### Application Monitoring

<LanguageContent lang="js">
```ts
    import winston from 'winston';

    // Configure logging
    const logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
      ]
    });

    // Request logging middleware
    app.use((req, res, next) => {
      const start = Date.now();
      res.on('finish', () => {
        const duration = Date.now() - start;
        logger.info('Request completed', {
          method: req.method,
          url: req.url,
          status: res.statusCode,
          duration,
          userAgent: req.get('User-Agent')
        });
      });
      next();
    });

    // Error handling middleware
    app.use((err, req, res, next) => {
      logger.error('Unhandled error', {
        error: err.message,
        stack: err.stack,
        url: req.url,
        method: req.method
      });
      res.status(500).json({ error: 'Internal server error' });
    });
    ```
</LanguageContent>

<LanguageContent lang="go">
```go
    import (
        "log/slog"
        "net/http"
        "time"
    )

    // Logging middleware
    func loggingMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // Wrap ResponseWriter to capture status code
            wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
            
            next.ServeHTTP(wrapped, r)
            
            duration := time.Since(start)
            
            slog.Info("Request completed",
                "method", r.Method,
                "url", r.URL.Path,
                "status", wrapped.statusCode,
                "duration", duration,
                "user_agent", r.UserAgent(),
            )
        })
    }

    type responseWriter struct {
        http.ResponseWriter
        statusCode int
    }

    func (rw *responseWriter) WriteHeader(code int) {
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
    }

    // Error recovery middleware
    func recoveryMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    slog.Error("Panic recovered",
                        "error", err,
                        "url", r.URL.Path,
                        "method", r.Method,
                    )
                    http.Error(w, "Internal server error", http.StatusInternalServerError)
                }
            }()
            next.ServeHTTP(w, r)
        })
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
```python
    import logging
    import time
    from flask import g, request

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s %(levelname)s %(name)s %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('app.log')
        ]
    )

    logger = logging.getLogger(__name__)

    # Request logging
    @app.before_request
    def before_request():
        g.start_time = time.time()

    @app.after_request
    def after_request(response):
        duration = time.time() - g.start_time
        logger.info(
            'Request completed',
            extra={
                'method': request.method,
                'url': request.url,
                'status': response.status_code,
                'duration': duration,
                'user_agent': request.user_agent.string
            }
        )
        return response

    # Error handling
    @app.errorhandler(Exception)
    def handle_exception(e):
        logger.error(
            'Unhandled exception',
            extra={
                'error': str(e),
                'url': request.url,
                'method': request.method
            },
            exc_info=True
        )
        return jsonify({'error': 'Internal server error'}), 500
    ```
</LanguageContent>

## Best Practices

### Security
1. **Use HTTPS only** in production
2. **Implement rate limiting** to prevent abuse
3. **Validate all inputs** before processing
4. **Use security headers** to prevent common attacks
5. **Keep dependencies updated** regularly

### Performance
1. **Implement caching** for frequently accessed data
2. **Use connection pooling** for database connections
3. **Optimize bundle size** and startup time
4. **Monitor memory usage** and optimize accordingly
5. **Use CDN** for static assets

### Reliability
1. **Implement health checks** for monitoring
2. **Use graceful shutdown** handling
3. **Implement circuit breakers** for external services
4. **Set up proper logging** and monitoring
5. **Use environment-specific configurations**

### Cost Optimization
1. **Choose appropriate instance sizes** for your workload
2. **Implement auto-scaling** based on demand
3. **Monitor resource usage** and optimize
4. **Use spot instances** where appropriate
5. **Implement request timeouts** to prevent resource waste

## Troubleshooting

### Common Issues

1. **Environment variable issues**:
   - Verify all required environment variables are set
