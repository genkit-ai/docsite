---
title: AlloyDB for PostgreSQL
description: Learn how to use AlloyDB for PostgreSQL with pgvector extension as a vector database for semantic search and RAG applications in Go.
---

import LanguageSelector from '../../../../components/LanguageSelector.astro';
import LanguageContent from '../../../../components/LanguageContent.astro';
import CopyMarkdownButton from '../../../../components/CopyMarkdownButton.astro';

<div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin: 1rem 0 1rem 0;">
  <LanguageSelector supportedLanguages="go" />
  <CopyMarkdownButton />
</div>

<LanguageContent lang="js">
  :::note[Feature unavailable for JavaScript] AlloyDB integration is not currently supported for JavaScript/TypeScript.
  You can implement AlloyDB integration yourself using standard PostgreSQL drivers with connection to AlloyDB endpoints
  and the [pgvector](https://github.com/pgvector/pgvector) extension. :::
</LanguageContent>

<LanguageContent lang="python">
  :::note[Feature unavailable for Python] AlloyDB integration is not currently supported for Python. You can implement
  AlloyDB integration yourself using standard PostgreSQL drivers with connection to AlloyDB endpoints and the
  [pgvector](https://github.com/pgvector/pgvector) extension. :::
</LanguageContent>

<LanguageContent lang="go">
AlloyDB for PostgreSQL is Google Cloud's fully managed PostgreSQL-compatible database service that provides enterprise-grade performance, availability, and scale. With the pgvector extension, AlloyDB becomes a powerful vector database for AI applications.

## Overview

AlloyDB with pgvector offers:

- **Fully managed service**: No infrastructure management required
- **PostgreSQL compatibility**: Use familiar SQL with vector operations
- **High performance**: Optimized for analytical and transactional workloads
- **Enterprise features**: Built-in security, backup, and monitoring
- **Seamless scaling**: Automatic scaling based on demand

## Prerequisites

- Google Cloud project with AlloyDB API enabled
- AlloyDB cluster and instance created
- Database with pgvector extension installed
- Appropriate IAM permissions for database access

## Setup

### Create AlloyDB instance

1. **Enable the AlloyDB API** in your Google Cloud project
2. **Create an AlloyDB cluster** in your preferred region
3. **Create a primary instance** within the cluster
4. **Enable pgvector extension** in your database:

```sql
CREATE EXTENSION IF NOT EXISTS vector;
```

### Configure authentication

AlloyDB supports multiple authentication methods:

- **Built-in authentication**: Username and password
- **IAM authentication**: Using Google Cloud IAM
- **Private IP**: Secure network access

## Implementation

The AlloyDB plugin provides the retriever implementation to search a [AlloyDB](https://cloud.google.com/alloydb/docs) database using the [pgvector](https://github.com/pgvector/pgvector) extension.

### Configuration

To use this plugin, follow these steps:

1. Import the plugin

   ```go
   import "github.com/firebase/genkit/go/plugins/alloydb"
   ```

2. Create a `PostgresEngine` instance:

   - Using basic authentication
     ```go
     pEngine, err := alloydb.NewPostgresEngine(ctx,
     		WithUser('user'),
     		WithPassword('password'),
     		WithAlloyDBInstance('my-project', 'us-central1', 'my-cluster', 'my-instance'),
     		WithDatabase('my-database')
     ```
   - Using email authentication
     ```go
     pEngine, err := alloydb.NewPostgresEngine(ctx,
     	WithAlloyDBInstance('my-project', 'us-central1', 'my-cluster', 'my-instance'),
     	WithDatabase('my-database'),
     	WithIAMAccountEmail('mail@company.com'))
     ```
   - Using custom pool

     ```go
     pool, err := pgxpool.New(ctx, "add_your_connection_string")
     if err != nil {
     	return err
     }

     pEngine, err := alloydb.NewPostgresEngine(ctx,
     	WithDatabase("db_test"),
     	WithPool(pool))
     ```

3. Create the Postgres plugin

   - Using plugin method Init

     ```go
     	postgres := &alloydb.Postgres{
     		engine: pEngine,
     	}

     	if err := (postgres).Init(ctx, g); err != nil {
     		return err
     	}
     ```

   - Using the genkit method init

     ```go
     	postgres := &alloydb.Postgres{
     		engine: pEngine,
     	}

     	g, err := genkit.Init(ctx, genkit.WithPlugins(postgres))

     	if  err != nil {
     		return err
     	}
     ```

### Usage

To add documents to a AlloyDB index, first create an index definition that specifies the features of the table:

```go
cfg := &alloydb.Config{
	TableName:             'documents',
	SchemaName:            'public',
	ContentColumn:         "content",
	EmbeddingColumn:       "embedding",
	MetadataColumns:       []string{"source", "category"},
	IDColumn:              "custom_id",
	MetadataJSONColumn:    "custom_metadata",
	Embedder:              embedder,
	EmbedderOptions:       nil,
}

doc, retriever, err := postgresql.DefineRetriever(ctx, g, postgres, cfg)
if err != nil {
  return err
}

docs := []*ai.Document{{
        Content: []*ai.Part{{
        Kind:        ai.PartText,
        ContentType: "text/plain",
        Text:        "The product features include...",
        }},
      Metadata: map[string]any{"source": "website", "category": "product-docs", "custom_id": "doc-123"},
  }}

if err := doc.Index(ctx, docs); err != nil {
    return err
}
```

Similarly, to retrieve documents from an index, use the retriever method:

```go
doc,  retriever, err := alloydb.DefineRetriever(ctx, g, postgres, cfg)
if err != nil {
  return err
}

d2 := ai.DocumentFromText( "The product features include..." , nil)

resp, err := retriever.Retrieve(ctx, &ai.RetrieverRequest{
    Query: d2,
    k:5,
    filter: "source='website' AND category='product-docs'"
})

if err != nil {
    return err
}
```

It's also possible to use the Retrieve method from Retriever

```go
d2 := ai.DocumentFromText( "The product features include..." , nil)

retrieverOptions := &alloydb.RetrieverOptions{
	k:5,
    filter: "source='website' AND category='product-docs'"
}

resp, err := ai.Retrieve(ctx, retriever,ai.WithDocs(d2), &ai.WithConfig(retrieverOptions))
if err != nil {
    return err
}
```

See the [Retrieval-augmented generation](/docs/rag) page for a general discussion on using retrievers for RAG.

## Database schema

Create the required table structure for storing documents and embeddings:

```sql
-- Create the documents table
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    embedding vector(768), -- Adjust dimension based on your embedder
    metadata JSONB,
    source VARCHAR(255),
    category VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for efficient similarity search
CREATE INDEX ON documents USING ivfflat (embedding vector_cosine_ops);

-- Create indexes for metadata filtering
CREATE INDEX ON documents USING GIN (metadata);
CREATE INDEX ON documents (source);
CREATE INDEX ON documents (category);
```

## Configuration options

### Connection settings

```go
// Using environment variables
pEngine, err := alloydb.NewPostgresEngine(ctx,
    alloydb.WithUser(os.Getenv("ALLOYDB_USERNAME")),
    alloydb.WithPassword(os.Getenv("ALLOYDB_PASSWORD")),
    alloydb.WithAlloyDBInstance(
        os.Getenv("GOOGLE_CLOUD_PROJECT"),
        os.Getenv("ALLOYDB_REGION"),
        os.Getenv("ALLOYDB_CLUSTER"),
        os.Getenv("ALLOYDB_INSTANCE"),
    ),
    alloydb.WithDatabase(os.Getenv("ALLOYDB_DATABASE")),
)
```

### IAM authentication

```go
// Using IAM authentication
pEngine, err := alloydb.NewPostgresEngine(ctx,
    alloydb.WithAlloyDBInstance("project", "region", "cluster", "instance"),
    alloydb.WithDatabase("database"),
    alloydb.WithIAMAccountEmail("service-account@project.iam.gserviceaccount.com"),
)
```

## Best practices

### Performance optimization

1. **Use appropriate indexes**: Create IVFFlat or HNSW indexes for vector similarity
2. **Optimize connection pooling**: Configure connection pools for better performance
3. **Batch operations**: Process multiple documents together when possible
4. **Query optimization**: Use metadata filters to reduce search space

### Security

1. **Use SSL connections**: Always enable SSL for AlloyDB connections
2. **IAM authentication**: Prefer IAM authentication over password-based auth
3. **Network security**: Use private IP and VPC peering when possible
4. **Least privilege**: Grant minimal required database permissions

### Monitoring and maintenance

1. **Monitor performance**: Use Google Cloud monitoring for AlloyDB metrics
2. **Regular backups**: Configure automated backups and point-in-time recovery
3. **Index maintenance**: Monitor and maintain vector indexes for optimal performance
4. **Resource scaling**: Monitor and adjust compute and storage resources

## Troubleshooting

### Common issues

**Connection failures:**

- Verify AlloyDB instance is running and accessible
- Check network connectivity and firewall rules
- Ensure correct connection parameters

**Authentication errors:**

- Verify username/password or IAM configuration
- Check database user permissions
- Ensure proper IAM roles for service accounts

**Performance issues:**

- Check if vector indexes are created and used
- Monitor connection pool utilization
- Optimize query patterns and batch sizes

**Vector search accuracy:**

- Verify embedding dimensions match table schema
- Check similarity thresholds and result limits
- Ensure consistent embedder usage for indexing and querying

## Next steps

- Learn about [RAG implementation](/docs/rag) for complete retrieval-augmented generation
- Explore [pgvector optimization](/docs/integrations/pgvector) techniques
- Review [evaluation strategies](/docs/evaluation) for measuring retrieval quality
- Set up [observability](/docs/observability-monitoring) for monitoring performance

</LanguageContent>
