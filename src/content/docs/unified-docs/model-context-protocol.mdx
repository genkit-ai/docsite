---
title: Model Context Protocol (MCP)
description: Learn how to extend Genkit's capabilities using the Model Context Protocol to connect with external tools, resources, and data sources across JavaScript, Go, and Python.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

The Model Context Protocol (MCP) is an open standard that enables AI applications to securely connect with external tools, resources, and data sources. With Genkit's MCP integration, you can:

- **Access external tools and data** from MCP servers as a client
- **Expose Genkit capabilities** as an MCP server for other applications
- **Build extensible AI workflows** that leverage external services and APIs
- **Create reusable tool ecosystems** that work across different AI applications

MCP bridges the gap between your AI models and the external world, enabling more powerful and context-aware applications.

## Core Concepts

### MCP Servers and Clients

- **MCP Server**: Provides tools, resources, and prompts that can be consumed by AI applications
- **MCP Client**: Consumes capabilities from MCP servers (your Genkit application acts as a client)
- **Tools**: Functions that the AI can call to perform actions or retrieve information
- **Resources**: Static or dynamic data sources that provide context to the AI
- **Prompts**: Reusable prompt templates with parameters

### How MCP Enhances AI Workflows

MCP enables your AI applications to:

1. **Access real-time data** from external APIs and databases
2. **Perform actions** in external systems (file operations, API calls, etc.)
3. **Leverage specialized tools** without implementing them from scratch
4. **Share capabilities** between different AI applications
5. **Maintain security** through controlled access to external resources

## Setting Up MCP with Genkit

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Install the MCP plugin:

    ```bash
    npm install genkit @genkit-ai/mcp
    ```

    Basic setup with multiple MCP servers:

    ```ts
    import { genkit } from 'genkit';
    import { googleAI } from '@genkit-ai/googleai';
    import { createMcpHost } from '@genkit-ai/mcp';

    const ai = genkit({
      plugins: [googleAI()],
    });

    // Create MCP host to manage multiple servers
    const mcpHost = createMcpHost({
      name: 'myMcpClients',
      mcpServers: {
        // Filesystem operations
        fs: {
          command: 'npx',
          args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()],
        },
        // Memory/context management
        memory: {
          command: 'npx',
          args: ['-y', '@modelcontextprotocol/server-memory'],
        },
        // Remote HTTP server
        weather: {
          url: 'https://api.weather.com/mcp',
          headers: {
            'Authorization': 'Bearer your-api-key',
          },
        },
      },
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Import the MCP package:

    ```bash
    go get github.com/firebase/genkit/go/plugins/mcp
    ```

    Basic setup:

    ```go
    package main

    import (
        "context"
        "log"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/mcp"
    )

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx)
        if err != nil {
            log.Fatal(err)
        }

        // Create MCP manager for multiple servers
        manager, err := mcp.NewMCPManager(mcp.MCPManagerOptions{
            Name: "my-app",
            MCPServers: []mcp.MCPServerConfig{
                {
                    Name: "filesystem",
                    Config: mcp.MCPClientOptions{
                        Name: "fs-server",
                        Stdio: &mcp.StdioConfig{
                            Command: "npx",
                            Args:    []string{"-y", "@modelcontextprotocol/server-filesystem", "."},
                        },
                    },
                },
                {
                    Name: "time",
                    Config: mcp.MCPClientOptions{
                        Name: "time-server",
                        Stdio: &mcp.StdioConfig{
                            Command: "uvx",
                            Args:    []string{"mcp-server-time"},
                        },
                    },
                },
            },
        })
        if err != nil {
            log.Fatal(err)
        }
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Install the MCP plugin:

    ```bash
    pip install genkit-mcp
    ```

    Basic setup:

    ```python
    import asyncio
    from genkit.ai import Genkit
    from genkit.plugins.mcp import MCPPlugin

    async def main():
        ai = Genkit(
            plugins=[
                MCPPlugin(
                    name="my-mcp-client",
                    servers={
                        "filesystem": {
                            "command": "npx",
                            "args": ["-y", "@modelcontextprotocol/server-filesystem", "."],
                        },
                        "memory": {
                            "command": "npx", 
                            "args": ["-y", "@modelcontextprotocol/server-memory"],
                        },
                        "weather": {
                            "url": "https://api.weather.com/mcp",
                            "headers": {
                                "Authorization": "Bearer your-api-key",
                            },
                        },
                    },
                ),
            ],
        )

    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </TabItem>
</Tabs>

## Using MCP in AI Workflows

### Accessing External Tools

MCP servers provide tools that your AI can use just like any other Genkit tool:

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    // Get all available tools from connected MCP servers
    const mcpTools = await mcpHost.getActiveTools(ai);

    // Use MCP tools in generation
    const response = await ai.generate({
      model: googleAI.model('gemini-2.5-flash'),
      prompt: 'Analyze the files in the current directory and remember key findings for later.',
      tools: mcpTools,
    });

    // Get tools from specific servers only
    const fsTools = await mcpHost.getActiveTools(ai, ['fs']);
    const memoryTools = await mcpHost.getActiveTools(ai, ['memory']);

    const response2 = await ai.generate({
      prompt: 'Read the README file and store its contents in memory.',
      tools: [...fsTools, ...memoryTools],
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    // Get all tools from all connected servers
    tools, err := manager.GetActiveTools(ctx, g)
    if err != nil {
        log.Fatal(err)
    }

    // Use tools in generation
    resp, err := genkit.Generate(ctx, g,
        ai.WithModel(myModel),
        ai.WithPrompt("What time is it and what files are in the current directory?"),
        ai.WithTools(tools...),
    )
    if err != nil {
        log.Fatal(err)
    }

    // Get tools from a specific server
    timeTool, err := manager.GetTool(ctx, g, "time", "get_current_time")
    if err != nil {
        log.Fatal(err)
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Get all available tools
    tools = await mcp_plugin.get_active_tools()

    # Use tools in generation
    response = await ai.generate(
        model="googleai/gemini-2.5-flash",
        prompt="What time is it and what files are in the current directory?",
        tools=tools,
    )

    # Get tools from specific servers
    fs_tools = await mcp_plugin.get_tools_from_server("filesystem")
    memory_tools = await mcp_plugin.get_tools_from_server("memory")

    response = await ai.generate(
        prompt="Read files and remember important information",
        tools=fs_tools + memory_tools,
    )
    ```
  </TabItem>
</Tabs>

### Working with Resources

MCP resources provide contextual information that can enhance your AI's understanding:

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    // Get resources from MCP servers
    const resources = await mcpHost.getActiveResources(ai);

    // Use resources to provide context
    const response = await ai.generate({
      prompt: 'Based on the available system information, recommend optimizations.',
      resources: resources,
    });

    // Access specific resources
    const systemInfo = await mcpHost.getResource('system', 'system://info');
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    // Get resources from MCP servers
    resources, err := manager.GetActiveResources(ctx, g)
    if err != nil {
        log.Fatal(err)
    }

    // Use resources in generation
    resp, err := genkit.Generate(ctx, g,
        ai.WithPrompt("Analyze the system information and provide recommendations"),
        ai.WithResources(resources...),
    )
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Get resources from MCP servers
    resources = await mcp_plugin.get_active_resources()

    # Use resources in generation
    response = await ai.generate(
        prompt="Analyze the system information and provide recommendations",
        resources=resources,
    )
    ```
  </TabItem>
</Tabs>

### Using MCP Prompts

MCP servers can provide reusable prompt templates:

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    // Get a prompt from an MCP server
    const analysisPrompt = await mcpHost.getPrompt('memory', 'analyze_data');

    // Use the prompt with parameters
    const response = await analysisPrompt({
      data: 'user interaction logs',
      focus: 'user behavior patterns'
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    // Get prompt from specific server
    prompt, err := manager.GetPrompt(ctx, g, "memory", "analyze_data", map[string]any{
        "data": "user interaction logs",
        "focus": "user behavior patterns",
    })
    if err != nil {
        log.Fatal(err)
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Get prompt from specific server
    prompt = await mcp_plugin.get_prompt("memory", "analyze_data")

    # Use the prompt with parameters
    response = await prompt({
        "data": "user interaction logs",
        "focus": "user behavior patterns"
    })
    ```
  </TabItem>
</Tabs>

## Building Flows with MCP

### Example: Document Analysis Workflow

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    const documentAnalysisFlow = ai.defineFlow(
      {
        name: 'documentAnalysis',
        inputSchema: z.object({
          directory: z.string(),
          analysisType: z.string(),
        }),
        outputSchema: z.object({
          summary: z.string(),
          insights: z.array(z.string()),
          recommendations: z.array(z.string()),
        }),
      },
      async ({ directory, analysisType }) => {
        // Get MCP tools for file operations and memory
        const tools = await mcpHost.getActiveTools(ai);

        // Step 1: Analyze documents in the directory
        const analysisResult = await ai.generate({
          prompt: `Analyze all documents in ${directory} for ${analysisType}. 
                   Read each file and extract key information.`,
          tools: tools,
        });

        // Step 2: Store findings in memory for later reference
        await ai.generate({
          prompt: `Store the following analysis results in memory: ${analysisResult.text}`,
          tools: tools,
        });

        // Step 3: Generate insights and recommendations
        const insights = await ai.generate({
          prompt: `Based on the document analysis, provide key insights and actionable recommendations.`,
          tools: tools,
        });

        return {
          summary: analysisResult.text,
          insights: insights.text.split('\n').filter(line => line.trim()),
          recommendations: [], // Parse from insights
        };
      }
    );
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    type DocumentAnalysisInput struct {
        Directory    string `json:"directory"`
        AnalysisType string `json:"analysis_type"`
    }

    type DocumentAnalysisOutput struct {
        Summary         string   `json:"summary"`
        Insights        []string `json:"insights"`
        Recommendations []string `json:"recommendations"`
    }

    documentAnalysisFlow := genkit.DefineFlow(g, "documentAnalysis",
        func(ctx context.Context, input DocumentAnalysisInput) (DocumentAnalysisOutput, error) {
            // Get MCP tools
            tools, err := manager.GetActiveTools(ctx, g)
            if err != nil {
                return DocumentAnalysisOutput{}, err
            }

            // Analyze documents
            resp, err := genkit.Generate(ctx, g,
                ai.WithPrompt(fmt.Sprintf("Analyze all documents in %s for %s", 
                    input.Directory, input.AnalysisType)),
                ai.WithTools(tools...),
            )
            if err != nil {
                return DocumentAnalysisOutput{}, err
            }

            return DocumentAnalysisOutput{
                Summary: resp.Text(),
                Insights: []string{}, // Parse from response
                Recommendations: []string{}, // Parse from response
            }, nil
        })
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    @ai.flow()
    async def document_analysis_flow(directory: str, analysis_type: str):
        # Get MCP tools
        tools = await mcp_plugin.get_active_tools()

        # Step 1: Analyze documents
        analysis_result = await ai.generate(
            prompt=f"Analyze all documents in {directory} for {analysis_type}. "
                   f"Read each file and extract key information.",
            tools=tools,
        )

        # Step 2: Store findings in memory
        await ai.generate(
            prompt=f"Store the following analysis results in memory: {analysis_result.text}",
            tools=tools,
        )

        # Step 3: Generate insights
        insights = await ai.generate(
            prompt="Based on the document analysis, provide key insights and recommendations.",
            tools=tools,
        )

        return {
            "summary": analysis_result.text,
            "insights": insights.text.split('\n'),
            "recommendations": []  # Parse from insights
        }
    ```
  </TabItem>
</Tabs>

## Advanced MCP Patterns

### Dynamic Server Management

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    // Connect to servers dynamically based on user needs
    const connectWeatherServer = async (apiKey: string) => {
      await mcpHost.connect('weather', {
        url: 'https://api.weather.com/mcp',
        headers: { 'Authorization': `Bearer ${apiKey}` },
      });
    };

    // Disconnect when no longer needed
    const disconnectWeatherServer = async () => {
      await mcpHost.disconnect('weather');
    };

    // Check server status
    const activeServers = await mcpHost.getActiveServers();
    console.log('Connected servers:', activeServers);
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    // Connect to server dynamically
    err = manager.Connect("weather", mcp.MCPClientOptions{
        Name: "weather-server",
        HTTP: &mcp.HTTPConfig{
            URL: "https://api.weather.com/mcp",
            Headers: map[string]string{
                "Authorization": "Bearer " + apiKey,
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // Disconnect when done
    err = manager.Disconnect("weather")
    if err != nil {
        log.Fatal(err)
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    # Connect to server dynamically
    await mcp_plugin.connect_server("weather", {
        "url": "https://api.weather.com/mcp",
        "headers": {
            "Authorization": f"Bearer {api_key}",
        },
    })

    # Disconnect server
    await mcp_plugin.disconnect_server("weather")

    # Check active servers
    active_servers = await mcp_plugin.get_active_servers()
    print(f"Active servers: {active_servers}")
    ```
  </TabItem>
</Tabs>

### Error Handling and Resilience

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    ```ts
    const robustMcpFlow = ai.defineFlow(
      {
        name: 'robustMcpFlow',
        inputSchema: z.object({ task: z.string() }),
        outputSchema: z.string(),
      },
      async ({ task }) => {
        try {
          // Wait for MCP connections to be ready
          await mcpHost.ready();

          // Get available tools with fallback
          const tools = await mcpHost.getActiveTools(ai);
          
          if (tools.length === 0) {
            return 'No MCP tools available, proceeding with basic capabilities.';
          }

          const response = await ai.generate({
            prompt: task,
            tools: tools,
          });

          return response.text;

        } catch (error) {
          console.error('MCP operation failed:', error);
          
          // Fallback to basic generation without MCP tools
          const fallbackResponse = await ai.generate({
            prompt: `${task} (Note: External tools unavailable)`,
          });

          return fallbackResponse.text;
        } finally {
          // Clean up resources
          await mcpHost.close();
        }
      }
    );
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```go
    robustMcpFlow := genkit.DefineFlow(g, "robustMcpFlow",
        func(ctx context.Context, input struct{ Task string }) (string, error) {
            // Graceful shutdown
            defer func() {
                if err := manager.Close(); err != nil {
                    log.Printf("Error closing MCP manager: %v", err)
                }
            }()

            // Try to get MCP tools
            tools, err := manager.GetActiveTools(ctx, g)
            if err != nil {
                log.Printf("Failed to get MCP tools: %v", err)
                // Fallback to basic generation
                resp, err := genkit.Generate(ctx, g,
                    ai.WithPrompt(input.Task + " (Note: External tools unavailable)"),
                )
                if err != nil {
                    return "", err
                }
                return resp.Text(), nil
            }

            // Use MCP tools
            resp, err := genkit.Generate(ctx, g,
                ai.WithPrompt(input.Task),
                ai.WithTools(tools...),
            )
            if err != nil {
                return "", err
            }

            return resp.Text(), nil
        })
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    @ai.flow()
    async def robust_mcp_flow(task: str) -> str:
        try:
            # Wait for MCP connections
            await mcp_plugin.ready()

            # Get available tools
            tools = await mcp_plugin.get_active_tools()
            
            if not tools:
                return "No MCP tools available, proceeding with basic capabilities."

            response = await ai.generate(
                prompt=task,
                tools=tools,
            )

            return response.text

        except Exception as error:
            print(f"MCP operation failed: {error}")
            
            # Fallback to basic generation
            fallback_response = await ai.generate(
                prompt=f"{task} (Note: External tools unavailable)",
            )

            return fallback_response.text

        finally:
            # Clean up connections
            await mcp_plugin.close()
    ```
  </TabItem>
</Tabs>

## Best Practices

### Security and Trust

1. **Validate MCP server sources**: Only connect to trusted MCP servers
2. **Sanitize inputs**: Validate all data passed to MCP tools
3. **Limit permissions**: Run MCP servers with minimal required permissions
4. **Monitor resource usage**: Track memory and CPU usage of MCP processes
5. **Use secure transports**: Prefer HTTPS and authenticated connections

### Performance Optimization

1. **Connection pooling**: Reuse MCP connections when possible
2. **Lazy loading**: Connect to servers only when needed
3. **Timeout configuration**: Set appropriate timeouts for MCP operations
4. **Resource cleanup**: Always close connections and clean up resources
5. **Caching**: Cache frequently accessed MCP resources

### Development and Testing

1. **Use MCP Inspector**: Test your MCP servers with the official inspector tool
2. **Mock MCP servers**: Create mock servers for testing and development
3. **Error simulation**: Test error handling with unreliable connections
4. **Performance testing**: Measure the impact of MCP operations on your flows
5. **Documentation**: Document your MCP integrations and dependencies

## Common MCP Servers

### Official MCP Servers

- **@modelcontextprotocol/server-filesystem**: File system operations
- **@modelcontextprotocol/server-memory**: Context and memory management
- **@modelcontextprotocol/server-sqlite**: SQLite database operations
- **@modelcontextprotocol/server-git**: Git repository operations

### Community MCP Servers

- **Weather APIs**: Real-time weather data
- **Database connectors**: PostgreSQL, MySQL, MongoDB
- **Cloud services**: AWS, GCP, Azure integrations
- **Development tools**: GitHub, Jira, Slack integrations

## Next Steps

- Learn about [tool calling](/unified-docs/tool-calling) to understand how MCP tools integrate with Genkit's tool system
- Explore [creating flows](/unified-docs/creating-flows) to build workflows that leverage MCP capabilities
- See the [MCP Server guide](/unified-docs/mcp-server) for creating your own MCP servers
- Check out the [official MCP documentation](https://modelcontextprotocol.io) for more details on the protocol
- Browse the [MCP server registry](https://github.com/modelcontextprotocol/servers) for available servers
