---
title: Astra DB Vector Database
description: Learn how to use DataStax Astra DB with Genkit across JavaScript, Go, and Python for serverless vector storage, semantic search, and RAG applications.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

DataStax Astra DB is a serverless vector database built on Apache Cassandra. It provides scalable vector storage with built-in embedding generation capabilities through Astra DB Vectorize, making it ideal for production AI applications that need reliable, distributed vector search.

## Installation and Setup

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Install the Astra DB plugin:

    ```bash
    npm install genkitx-astra-db
    ```

    Configure the plugin when initializing Genkit:

    ```ts
    import { genkit } from 'genkit';
    import { astraDB } from 'genkitx-astra-db';
    import { googleAI } from '@genkit-ai/googleai';

    const ai = genkit({
      plugins: [
        googleAI(),
        astraDB([
          {
            clientParams: {
              applicationToken: process.env.ASTRA_DB_APPLICATION_TOKEN,
              apiEndpoint: process.env.ASTRA_DB_API_ENDPOINT,
              keyspace: 'default_keyspace',
            },
            collectionName: 'documents',
            embedder: googleAI.embedder('gemini-embedding-001'),
          },
        ]),
      ],
    });
    ```

    ### Prerequisites

    1. **DataStax Account**: [Sign up for a free DataStax account](https://astra.datastax.com/signup)
    2. **Astra DB Database**: Create a Serverless Vector database
    3. **Collection**: Create a collection with dimensions matching your embedding model
    4. **Credentials**: Get your Application Token and API Endpoint

    ### Environment Variables

    ```bash
    export ASTRA_DB_APPLICATION_TOKEN=your_application_token
    export ASTRA_DB_API_ENDPOINT=your_astra_db_endpoint
    ```

    ### Using Astra DB Vectorize

    You can use Astra DB's built-in embedding generation:

    ```ts
    const ai = genkit({
      plugins: [
        astraDB([
          {
            clientParams: {
              applicationToken: process.env.ASTRA_DB_APPLICATION_TOKEN,
              apiEndpoint: process.env.ASTRA_DB_API_ENDPOINT,
              keyspace: 'default_keyspace',
            },
            collectionName: 'documents',
            // No embedder needed - Astra DB Vectorize handles embedding generation
          },
        ]),
      ],
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    For Go applications, you can use Astra DB through the DataStax Go driver:

    ```bash
    go get github.com/datastax/astra-db-go
    ```

    ```go
    package main

    import (
        "context"
        "os"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/astradb"
        "github.com/firebase/genkit/go/plugins/googleai"
    )

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(
                &googleai.GoogleAI{},
                &astradb.AstraDB{
                    ApplicationToken: os.Getenv("ASTRA_DB_APPLICATION_TOKEN"),
                    APIEndpoint:      os.Getenv("ASTRA_DB_API_ENDPOINT"),
                    Keyspace:         "default_keyspace",
                    Collections: []astradb.CollectionConfig{
                        {
                            Name:     "documents",
                            Embedder: "googleai/gemini-embedding-001",
                        },
                    },
                },
            ),
        )
        if err != nil {
            log.Fatal(err)
        }
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    For Python applications, install the Astra DB client:

    ```bash
    pip install astrapy genkit-plugin-astradb
    ```

    ```python
    import os
    from genkit.ai import Genkit
    from genkit.plugins.astradb import AstraDB
    from genkit.plugins.google_genai import GoogleGenAI

    ai = Genkit(
        plugins=[
            GoogleGenAI(),
            AstraDB(
                application_token=os.getenv("ASTRA_DB_APPLICATION_TOKEN"),
                api_endpoint=os.getenv("ASTRA_DB_API_ENDPOINT"),
                keyspace="default_keyspace",
                collections=[
                    {
                        "name": "documents",
                        "embedder": "googleai/gemini-embedding-001",
                    }
                ],
            ),
        ],
    )
    ```
  </TabItem>
</Tabs>

## Basic Usage

### Document Indexing

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Index documents for semantic search:

    ```ts
    import { astraDBIndexerRef } from 'genkitx-astra-db';
    import { Document } from 'genkit';

    // Create indexer reference
    const documentsIndexer = astraDBIndexerRef({
      collectionName: 'documents',
    });

    // Prepare documents for indexing
    const documents: Document[] = [
      {
        content: 'Astra DB is a serverless vector database built on Apache Cassandra.',
        metadata: {
          title: 'Astra DB Overview',
          category: 'database',
          source: 'documentation',
          score: 95,
        },
      },
      {
        content: 'Serverless databases provide automatic scaling and management.',
        metadata: {
          title: 'Serverless Architecture',
          category: 'technology',
          source: 'blog',
          score: 88,
        },
      },
    ];

    // Index documents
    await ai.index({
      indexer: documentsIndexer,
      documents,
    });

    // Batch indexing for large datasets
    const batchSize = 100;
    for (let i = 0; i < largeDocumentSet.length; i += batchSize) {
      const batch = largeDocumentSet.slice(i, i + batchSize);
      await ai.index({
        indexer: documentsIndexer,
        documents: batch,
      });
    }
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Index documents for semantic search:

    ```go
    import (
        "context"
        "github.com/firebase/genkit/go/ai"
        "github.com/firebase/genkit/go/genkit"
    )

    func indexDocuments(ctx context.Context) error {
        documents := []ai.Document{
            {
                Content: "Astra DB is a serverless vector database built on Apache Cassandra.",
                Metadata: map[string]interface{}{
                    "title":    "Astra DB Overview",
                    "category": "database",
                    "source":   "documentation",
                    "score":    95,
                },
            },
            {
                Content: "Serverless databases provide automatic scaling and management.",
                Metadata: map[string]interface{}{
                    "title":    "Serverless Architecture",
                    "category": "technology",
                    "source":   "blog",
                    "score":    88,
                },
            },
        }

        // Index documents
        err := genkit.Index(ctx, g,
            ai.WithIndexer("astradb/documents"),
            ai.WithDocuments(documents),
        )
        if err != nil {
            return fmt.Errorf("failed to index documents: %w", err)
        }

        return nil
    }

    // Batch indexing function
    func batchIndexDocuments(ctx context.Context, documents []ai.Document, batchSize int) error {
        for i := 0; i < len(documents); i += batchSize {
            end := i + batchSize
            if end > len(documents) {
                end = len(documents)
            }
            
            batch := documents[i:end]
            err := genkit.Index(ctx, g,
                ai.WithIndexer("astradb/documents"),
                ai.WithDocuments(batch),
            )
            if err != nil {
                return fmt.Errorf("failed to index batch: %w", err)
            }
        }
        return nil
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Index documents for semantic search:

    ```python
    from typing import List, Dict, Any

    # Prepare documents for indexing
    documents = [
        {
            "content": "Astra DB is a serverless vector database built on Apache Cassandra.",
            "metadata": {
                "title": "Astra DB Overview",
                "category": "database",
                "source": "documentation",
                "score": 95,
            },
        },
        {
            "content": "Serverless databases provide automatic scaling and management.",
            "metadata": {
                "title": "Serverless Architecture",
                "category": "technology",
                "source": "blog",
                "score": 88,
            },
        },
    ]

    # Index documents
    async def index_documents(docs: List[Dict[str, Any]], collection_name: str = "documents"):
        try:
            indexer = f"astradb/{collection_name}"
            
            await ai.index(
                indexer=indexer,
                documents=docs
            )
            
            return {"indexed": len(docs), "success": True}
        except Exception as error:
            print(f"Indexing failed: {error}")
            return {"indexed": 0, "success": False}

    # Batch indexing for large datasets
    async def batch_index_documents(
        docs: List[Dict[str, Any]], 
        collection_name: str = "documents",
        batch_size: int = 100
    ):
        total_indexed = 0
        
        for i in range(0, len(docs), batch_size):
            batch = docs[i:i + batch_size]
            
            try:
                await ai.index(
                    indexer=f"astradb/{collection_name}",
                    documents=batch
                )
                total_indexed += len(batch)
            except Exception as error:
                print(f"Batch indexing failed: {error}")
                break
        
        return {"indexed": total_indexed, "success": total_indexed == len(docs)}
    ```
  </TabItem>
</Tabs>

### Document Retrieval

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Retrieve relevant documents using semantic search:

    ```ts
    import { astraDBRetrieverRef } from 'genkitx-astra-db';

    // Create retriever reference
    const documentsRetriever = astraDBRetrieverRef({
      collectionName: 'documents',
    });

    // Basic retrieval
    const query = "What is a serverless database?";
    const docs = await ai.retrieve({
      retriever: documentsRetriever,
      query,
      options: {
        k: 5, // Number of documents to retrieve
      },
    });

    console.log('Retrieved documents:', docs);

    // Advanced retrieval with filtering
    type DocumentSchema = {
      _id: string;
      text: string;
      score: number;
      category: string;
    };

    const typedRetriever = astraDBRetrieverRef<DocumentSchema>({
      collectionName: 'documents',
    });

    const filteredDocs = await ai.retrieve({
      retriever: typedRetriever,
      query,
      options: {
        k: 3,
        filter: {
          score: { $gt: 90 }, // Only documents with score > 90
          category: 'database', // Only database-related documents
        },
      },
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Retrieve relevant documents using semantic search:

    ```go
    // Basic retrieval
    func retrieveDocuments(ctx context.Context, query string) ([]ai.Document, error) {
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("astradb/documents"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k": 5,
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("retrieval failed: %w", err)
        }

        return docs, nil
    }

    // Advanced retrieval with filtering
    func advancedRetrieve(ctx context.Context, query string, limit int, filter map[string]interface{}) ([]ai.Document, error) {
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("astradb/documents"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k":      limit,
                "filter": filter,
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("advanced retrieval failed: %w", err)
        }

        return docs, nil
    }

    // Usage example with filtering
    func searchHighQualityDocuments(ctx context.Context, query string) ([]ai.Document, error) {
        filter := map[string]interface{}{
            "score": map[string]interface{}{
                "$gt": 90,
            },
            "category": "database",
        }

        return advancedRetrieve(ctx, query, 3, filter)
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Retrieve relevant documents using semantic search:

    ```python
    from typing import List, Dict, Any, Optional

    # Basic retrieval
    async def retrieve_documents(query: str, collection_name: str = "documents", k: int = 5) -> List[Dict[str, Any]]:
        try:
            retriever = f"astradb/{collection_name}"
            docs = await ai.retrieve(
                retriever=retriever,
                query=query,
                options={"k": k}
            )
            return docs
        except Exception as error:
            print(f"Retrieval failed: {error}")
            return []

    # Advanced retrieval with filtering
    async def advanced_retrieve(
        query: str,
        collection_name: str = "documents",
        k: int = 5,
        filter_criteria: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        try:
            retriever = f"astradb/{collection_name}"
            
            options = {"k": k}
            if filter_criteria:
                options["filter"] = filter_criteria
            
            docs = await ai.retrieve(
                retriever=retriever,
                query=query,
                options=options
            )
            
            return docs
        except Exception as error:
            print(f"Advanced retrieval failed: {error}")
            return []

    # Usage examples
    async def search_high_quality_documents(query: str) -> List[Dict[str, Any]]:
        # Search for high-quality database documents
        filter_criteria = {
            "score": {"$gt": 90},
            "category": "database"
        }
        
        return await advanced_retrieve(
            query=query,
            k=3,
            filter_criteria=filter_criteria
        )
    ```
  </TabItem>
</Tabs>

## Advanced Features

### Hybrid Search with Filtering

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Combine vector similarity with metadata filtering:

    ```ts
    // Complex filtering with multiple conditions
    const complexRetriever = astraDBRetrieverRef<DocumentSchema>({
      collectionName: 'documents',
    });

    const complexSearch = await ai.retrieve({
      retriever: complexRetriever,
      query: "database performance optimization",
      options: {
        k: 10,
        filter: {
          $and: [
            { score: { $gte: 85 } },
            { category: { $in: ['database', 'performance'] } },
            { source: { $ne: 'deprecated' } },
          ],
        },
      },
    });

    // Range-based filtering
    const recentDocuments = await ai.retrieve({
      retriever: complexRetriever,
      query: "latest database features",
      options: {
        k: 5,
        filter: {
          score: { $gte: 80, $lte: 100 },
          category: 'database',
        },
      },
    });

    // Text-based filtering
    const specificSource = await ai.retrieve({
      retriever: complexRetriever,
      query: "vector search capabilities",
      options: {
        k: 3,
        filter: {
          source: { $regex: 'official.*docs' },
          category: 'database',
        },
      },
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Combine vector similarity with metadata filtering:

    ```go
    // Complex filtering function
    func performComplexSearch(ctx context.Context, query string) ([]ai.Document, error) {
        // Multiple condition filtering
        complexFilter := map[string]interface{}{
            "$and": []map[string]interface{}{
                {"score": map[string]interface{}{"$gte": 85}},
                {"category": map[string]interface{}{"$in": []string{"database", "performance"}}},
                {"source": map[string]interface{}{"$ne": "deprecated"}},
            },
        }

        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("astradb/documents"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k":      10,
                "filter": complexFilter,
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("complex search failed: %w", err)
        }

        return docs, nil
    }

    // Range-based filtering
    func searchByScoreRange(ctx context.Context, query string, minScore, maxScore int) ([]ai.Document, error) {
        filter := map[string]interface{}{
            "score": map[string]interface{}{
                "$gte": minScore,
                "$lte": maxScore,
            },
            "category": "database",
        }

        return advancedRetrieve(ctx, query, 5, filter)
    }

    // Text pattern filtering
    func searchBySourcePattern(ctx context.Context, query, pattern string) ([]ai.Document, error) {
        filter := map[string]interface{}{
            "source": map[string]interface{}{
                "$regex": pattern,
            },
            "category": "database",
        }

        return advancedRetrieve(ctx, query, 3, filter)
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Combine vector similarity with metadata filtering:

    ```python
    # Complex filtering with multiple conditions
    async def perform_complex_search(query: str) -> List[Dict[str, Any]]:
        complex_filter = {
            "$and": [
                {"score": {"$gte": 85}},
                {"category": {"$in": ["database", "performance"]}},
                {"source": {"$ne": "deprecated"}},
            ]
        }
        
        return await advanced_retrieve(
            query=query,
            k=10,
            filter_criteria=complex_filter
        )

    # Range-based filtering
    async def search_by_score_range(
        query: str, 
        min_score: int = 80, 
        max_score: int = 100
    ) -> List[Dict[str, Any]]:
        filter_criteria = {
            "score": {"$gte": min_score, "$lte": max_score},
            "category": "database"
        }
        
        return await advanced_retrieve(
            query=query,
            k=5,
            filter_criteria=filter_criteria
        )

    # Text pattern filtering
    async def search_by_source_pattern(query: str, pattern: str) -> List[Dict[str, Any]]:
        filter_criteria = {
            "source": {"$regex": pattern},
            "category": "database"
        }
        
        return await advanced_retrieve(
            query=query,
            k=3,
            filter_criteria=filter_criteria
        )

    # Comprehensive search example
    async def comprehensive_search_example():
        # Search for high-quality recent database documentation
        results = await perform_complex_search("vector database optimization")
        
        # Search within score range
        range_results = await search_by_score_range("serverless architecture", 85, 95)
        
        # Search official documentation
        official_docs = await search_by_source_pattern("database features", "official.*docs")
        
        return {
            "complex_search": results,
            "score_range": range_results,
            "official_docs": official_docs
        }
    ```
  </TabItem>
</Tabs>

## Best Practices

### Database Configuration

1. **Collection Design**: Choose appropriate dimensions for your embedding model
2. **Keyspace Organization**: Use keyspaces to organize different data types
3. **Indexing Strategy**: Leverage Astra DB's automatic indexing capabilities
4. **Schema Design**: Structure metadata for effective filtering

### Performance Optimization

1. **Batch Operations**: Index documents in batches for better throughput
2. **Connection Pooling**: Reuse connections for multiple operations
3. **Filtering Strategy**: Use metadata filters to reduce search space
4. **Embedding Strategy**: Consider using Astra DB Vectorize for built-in embedding generation

### Production Deployment

1. **Security**: Use secure application tokens and rotate them regularly
2. **Monitoring**: Monitor query performance and database metrics
3. **Scaling**: Leverage Astra DB's automatic scaling capabilities
4. **Backup**: Implement backup strategies for critical data

### Cost Optimization

1. **Efficient Queries**: Use appropriate k values and filters
2. **Data Lifecycle**: Archive or delete old documents when appropriate
3. **Resource Monitoring**: Monitor usage to optimize costs
4. **Vectorize Usage**: Consider Astra DB Vectorize to reduce external embedding costs

## Next Steps

- Learn about [RAG implementation](/unified-docs/rag) to build complete retrieval-augmented generation systems
- Explore [creating flows](/unified-docs/creating-flows) to build structured AI workflows with vector search
- See [deployment guides](/unified-docs/deployment) for production deployment strategies
- Check out other vector database options for different use cases
