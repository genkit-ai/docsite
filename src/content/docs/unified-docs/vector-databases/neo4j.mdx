---
title: Neo4j Graph Vector Database
description: Learn how to use Neo4j with Genkit across JavaScript, Go, and Python for graph-based vector storage, semantic search, and knowledge graph applications.
---

import LangTabs from '@/components/LangTabs.astro';
import LangTabItem from '@/components/LangTabItem.astro';

Neo4j is a graph database that combines the power of graph relationships with vector search capabilities. It enables you to store documents as nodes with vector embeddings while maintaining rich relationships between entities, making it ideal for knowledge graphs, recommendation systems, and complex AI applications that need both semantic search and graph traversal.

## Installation and Setup

<LangTabs>
  <LangTabItem lang="js">
    Install the Neo4j plugin:

    ```bash
    npm install genkitx-neo4j
    ```

    Configure the plugin when initializing Genkit:

    ```ts
    import { genkit } from 'genkit';
    import { neo4j } from 'genkitx-neo4j';
    import { googleAI } from '@genkit-ai/googleai';

    const ai = genkit({
      plugins: [
        googleAI(),
        neo4j([
          {
            indexId: 'documents-index',
            embedder: googleAI.embedder('gemini-embedding-001'),
            clientParams: {
              url: process.env.NEO4J_URI || 'bolt://localhost:7687',
              username: process.env.NEO4J_USERNAME || 'neo4j',
              password: process.env.NEO4J_PASSWORD,
              database: process.env.NEO4J_DATABASE || 'neo4j',
            },
          },
        ]),
      ],
    });
    ```

    ### Environment Variables

    ```bash
    export NEO4J_URI=bolt://localhost:7687
    export NEO4J_USERNAME=neo4j
    export NEO4J_PASSWORD=your_password
    export NEO4J_DATABASE=neo4j
    ```

    ### Prerequisites

    1. **Neo4j Database**: Install Neo4j Desktop, Neo4j AuraDB, or run Neo4j in Docker
    2. **Vector Index**: Create a vector index in your Neo4j database
    3. **Credentials**: Configure authentication credentials

    ### Creating Vector Index in Neo4j

    ```cypher
    // Create a vector index for document embeddings
    CREATE VECTOR INDEX documents_vector_index
    FOR (n:Document)
    ON n.embedding
    OPTIONS {indexConfig: {
      `vector.dimensions`: 768,
      `vector.similarity_function`: 'cosine'
    }}
    ```
  </LangTabItem>
  <LangTabItem lang="go">
    For Go applications, you can use Neo4j through the official Go driver:

    ```bash
    go get github.com/neo4j/neo4j-go-driver/v5/neo4j
    ```

    ```go
    package main

    import (
        "context"
        "os"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/neo4j"
        "github.com/firebase/genkit/go/plugins/googleai"
    )

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(
                &googleai.GoogleAI{},
                &neo4j.Neo4j{
                    URI:      os.Getenv("NEO4J_URI"),
                    Username: os.Getenv("NEO4J_USERNAME"),
                    Password: os.Getenv("NEO4J_PASSWORD"),
                    Database: os.Getenv("NEO4J_DATABASE"),
                    Indexes: []neo4j.IndexConfig{
                        {
                            Name:     "documents-index",
                            Embedder: "googleai/gemini-embedding-001",
                        },
                    },
                },
            ),
        )
        if err != nil {
            log.Fatal(err)
        }
    }
    ```
  </LangTabItem>
  <LangTabItem lang="python">
    For Python applications, install the Neo4j driver:

    ```bash
    pip install neo4j genkit-plugin-neo4j
    ```

    ```python
    import os
    from genkit.ai import Genkit
    from genkit.plugins.neo4j import Neo4j
    from genkit.plugins.google_genai import GoogleGenAI

    ai = Genkit(
        plugins=[
            GoogleGenAI(),
            Neo4j(
                uri=os.getenv("NEO4J_URI", "bolt://localhost:7687"),
                username=os.getenv("NEO4J_USERNAME", "neo4j"),
                password=os.getenv("NEO4J_PASSWORD"),
                database=os.getenv("NEO4J_DATABASE", "neo4j"),
                indexes=[
                    {
                        "name": "documents-index",
                        "embedder": "googleai/gemini-embedding-001",
                    }
                ],
            ),
        ],
    )
    ```
  </LangTabItem>
</LangTabs>

## Basic Usage

### Document Indexing

<LangTabs>
  <LangTabItem lang="js">
    Index documents as graph nodes with vector embeddings:

    ```ts
    import { neo4jIndexerRef } from 'genkitx-neo4j';
    import { Document } from 'genkit';

    // Create indexer reference
    const documentsIndexer = neo4jIndexerRef({
      indexId: 'documents-index',
    });

    // Prepare documents for indexing
    const documents: Document[] = [
      {
        content: 'Neo4j combines graph database capabilities with vector search.',
        metadata: {
          title: 'Neo4j Overview',
          category: 'database',
          author: 'Neo4j Team',
          tags: ['graph', 'vector', 'database'],
          nodeId: 'doc-1',
        },
      },
      {
        content: 'Knowledge graphs represent entities and their relationships.',
        metadata: {
          title: 'Knowledge Graphs',
          category: 'technology',
          author: 'AI Researcher',
          tags: ['knowledge', 'graph', 'ai'],
          nodeId: 'doc-2',
        },
      },
    ];

    // Index documents
    await ai.index({
      indexer: documentsIndexer,
      documents,
    });

    // Create relationships between documents
    const createRelationships = async () => {
      // This would typically be done through direct Neo4j queries
      // after indexing to establish relationships between nodes
      console.log('Documents indexed as graph nodes with embeddings');
    };
    ```
  </LangTabItem>
  <LangTabItem lang="go">
    Index documents as graph nodes with vector embeddings:

    ```go
    import (
        "context"
        "github.com/firebase/genkit/go/ai"
        "github.com/firebase/genkit/go/genkit"
    )

    func indexDocuments(ctx context.Context) error {
        documents := []ai.Document{
            {
                Content: "Neo4j combines graph database capabilities with vector search.",
                Metadata: map[string]interface{}{
                    "title":    "Neo4j Overview",
                    "category": "database",
                    "author":   "Neo4j Team",
                    "tags":     []string{"graph", "vector", "database"},
                    "nodeId":   "doc-1",
                },
            },
            {
                Content: "Knowledge graphs represent entities and their relationships.",
                Metadata: map[string]interface{}{
                    "title":    "Knowledge Graphs",
                    "category": "technology",
                    "author":   "AI Researcher",
                    "tags":     []string{"knowledge", "graph", "ai"},
                    "nodeId":   "doc-2",
                },
            },
        }

        // Index documents
        err := genkit.Index(ctx, g,
            ai.WithIndexer("neo4j/documents-index"),
            ai.WithDocuments(documents),
        )
        if err != nil {
            return fmt.Errorf("failed to index documents: %w", err)
        }

        return nil
    }

    // Create relationships between indexed documents
    func createDocumentRelationships(ctx context.Context) error {
        // This would typically involve direct Neo4j queries
        // to establish relationships between document nodes
        fmt.Println("Documents indexed as graph nodes with embeddings")
        return nil
    }
    ```
  </LangTabItem>
  <LangTabItem lang="python">
    Index documents as graph nodes with vector embeddings:

    ```python
    from typing import List, Dict, Any

    # Prepare documents for indexing
    documents = [
        {
            "content": "Neo4j combines graph database capabilities with vector search.",
            "metadata": {
                "title": "Neo4j Overview",
                "category": "database",
                "author": "Neo4j Team",
                "tags": ["graph", "vector", "database"],
                "node_id": "doc-1",
            },
        },
        {
            "content": "Knowledge graphs represent entities and their relationships.",
            "metadata": {
                "title": "Knowledge Graphs",
                "category": "technology",
                "author": "AI Researcher",
                "tags": ["knowledge", "graph", "ai"],
                "node_id": "doc-2",
            },
        },
    ]

    # Index documents
    async def index_documents(docs: List[Dict[str, Any]], index_name: str = "documents-index"):
        try:
            indexer = f"neo4j/{index_name}"
            
            await ai.index(
                indexer=indexer,
                documents=docs
            )
            
            return {"indexed": len(docs), "success": True}
        except Exception as error:
            print(f"Indexing failed: {error}")
            return {"indexed": 0, "success": False}

    # Create relationships between documents
    async def create_document_relationships():
        # This would typically involve direct Neo4j queries
        # to establish relationships between document nodes
        print("Documents indexed as graph nodes with embeddings")
        return {"relationships_created": True}
    ```
  </LangTabItem>
</LangTabs>

### Document Retrieval

<LangTabs>
  <LangTabItem lang="js">
    Retrieve relevant documents using vector similarity:

    ```ts
    import { neo4jRetrieverRef } from 'genkitx-neo4j';

    // Create retriever reference
    const documentsRetriever = neo4jRetrieverRef({
      indexId: 'documents-index',
      displayName: 'Knowledge Base',
    });

    // Basic retrieval
    const query = "What is a knowledge graph?";
    const docs = await ai.retrieve({
      retriever: documentsRetriever,
      query,
      options: {
        k: 5, // Number of documents to retrieve (max 1000)
      },
    });

    console.log('Retrieved documents:', docs);

    // Advanced retrieval with custom scoring
    const advancedDocs = await ai.retrieve({
      retriever: documentsRetriever,
      query: "graph database relationships",
      options: {
        k: 3,
        // Additional Neo4j-specific options can be passed here
      },
    });

    // Retrieve with specific author filter (would require custom Cypher)
    const authorSpecificRetriever = neo4jRetrieverRef({
      indexId: 'documents-index',
      displayName: 'Author-Specific Search',
    });
    ```
  </LangTabItem>
  <LangTabItem lang="go">
    Retrieve relevant documents using vector similarity:

    ```go
    // Basic retrieval
    func retrieveDocuments(ctx context.Context, query string) ([]ai.Document, error) {
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("neo4j/documents-index"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k": 5,
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("retrieval failed: %w", err)
        }

        return docs, nil
    }

    // Advanced retrieval with custom options
    func advancedRetrieve(ctx context.Context, query string, limit int) ([]ai.Document, error) {
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("neo4j/documents-index"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k": limit,
                // Additional Neo4j-specific options
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("advanced retrieval failed: %w", err)
        }

        return docs, nil
    }

    // Usage example
    func searchKnowledgeBase(ctx context.Context) error {
        // Basic search
        docs, err := retrieveDocuments(ctx, "What is a knowledge graph?")
        if err != nil {
            return err
        }

        // Advanced search
        advancedDocs, err := advancedRetrieve(ctx, "graph database relationships", 3)
        if err != nil {
            return err
        }

        fmt.Printf("Found %d documents, %d advanced results\n", len(docs), len(advancedDocs))
        return nil
    }
    ```
  </LangTabItem>
  <LangTabItem lang="python">
    Retrieve relevant documents using vector similarity:

    ```python
    from typing import List, Dict, Any, Optional

    # Basic retrieval
    async def retrieve_documents(query: str, index_name: str = "documents-index", k: int = 5) -> List[Dict[str, Any]]:
        try:
            retriever = f"neo4j/{index_name}"
            docs = await ai.retrieve(
                retriever=retriever,
                query=query,
                options={"k": k}
            )
            return docs
        except Exception as error:
            print(f"Retrieval failed: {error}")
            return []

    # Advanced retrieval with custom options
    async def advanced_retrieve(
        query: str,
        index_name: str = "documents-index",
        k: int = 5,
        custom_options: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        try:
            retriever = f"neo4j/{index_name}"
            
            options = {"k": k}
            if custom_options:
                options.update(custom_options)
            
            docs = await ai.retrieve(
                retriever=retriever,
                query=query,
                options=options
            )
            
            return docs
        except Exception as error:
            print(f"Advanced retrieval failed: {error}")
            return []

    # Usage examples
    async def search_knowledge_base():
        # Basic search
        docs = await retrieve_documents("What is a knowledge graph?", k=5)
        
        # Advanced search
        advanced_docs = await advanced_retrieve(
            query="graph database relationships",
            k=3,
            custom_options={"include_metadata": True}
        )
        
        print(f"Found {len(docs)} documents, {len(advanced_docs)} advanced results")
        return docs, advanced_docs
    ```
  </LangTabItem>
</LangTabs>

## Advanced Features

### Graph-Enhanced Retrieval

<LangTabs>
  <LangTabItem lang="js">
    Combine vector search with graph traversal for enhanced results:

    ```ts
    // Custom retrieval that combines vector search with graph relationships
    const graphEnhancedRetrieval = async (query: string) => {
      // First, perform vector search
      const vectorResults = await ai.retrieve({
        retriever: documentsRetriever,
        query,
        options: { k: 3 },
      });

      // Then, use Neo4j driver directly for graph traversal
      // This would require additional Neo4j driver setup
      const enhancedResults = vectorResults.map(doc => ({
        ...doc,
        relatedNodes: [], // Would be populated by graph traversal
      }));

      return enhancedResults;
    };

    // Knowledge graph construction
    const buildKnowledgeGraph = async (documents: Document[]) => {
      // Index documents first
      await ai.index({
        indexer: documentsIndexer,
        documents,
      });

      // Create relationships based on content similarity or metadata
      // This would involve direct Cypher queries to Neo4j
      console.log('Knowledge graph constructed with vector-enabled nodes');
    };

    // Entity relationship extraction
    const extractEntityRelationships = async (text: string) => {
      // Use AI to extract entities and relationships
      const { text: entities } = await ai.generate({
        model: googleAI.model('gemini-2.5-flash'),
        prompt: `Extract entities and relationships from: ${text}
        
        Format as JSON with entities and relationships arrays.`,
      });

      return JSON.parse(entities);
    };
    ```
  </LangTabItem>
  <LangTabItem lang="go">
    Combine vector search with graph traversal for enhanced results:

    ```go
    import (
        "encoding/json"
        "fmt"
        "github.com/neo4j/neo4j-go-driver/v5/neo4j"
    )

    // Graph-enhanced retrieval combining vector search with graph traversal
    func graphEnhancedRetrieval(ctx context.Context, query string) ([]map[string]interface{}, error) {
        // First, perform vector search
        vectorResults, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("neo4j/documents-index"),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{"k": 3}),
        )
        if err != nil {
            return nil, fmt.Errorf("vector search failed: %w", err)
        }

        // Enhance with graph traversal (requires Neo4j driver)
        enhancedResults := make([]map[string]interface{}, len(vectorResults))
        for i, doc := range vectorResults {
            enhancedResults[i] = map[string]interface{}{
                "document":     doc,
                "relatedNodes": []interface{}{}, // Would be populated by graph traversal
            }
        }

        return enhancedResults, nil
    }

    // Knowledge graph construction
    func buildKnowledgeGraph(ctx context.Context, documents []ai.Document) error {
        // Index documents first
        err := genkit.Index(ctx, g,
            ai.WithIndexer("neo4j/documents-index"),
            ai.WithDocuments(documents),
        )
        if err != nil {
            return fmt.Errorf("failed to index documents: %w", err)
        }

        // Create relationships based on content similarity or metadata
        // This would involve direct Cypher queries to Neo4j
        fmt.Println("Knowledge graph constructed with vector-enabled nodes")
        return nil
    }

    // Entity relationship extraction
    func extractEntityRelationships(ctx context.Context, text string) (map[string]interface{}, error) {
        prompt := fmt.Sprintf(`Extract entities and relationships from: %s
        
        Format as JSON with entities and relationships arrays.`, text)

        resp, err := genkit.Generate(ctx, g,
            ai.WithModel("googleai/gemini-2.5-flash"),
            ai.WithPrompt(prompt),
        )
        if err != nil {
            return nil, fmt.Errorf("entity extraction failed: %w", err)
        }

        var result map[string]interface{}
        err = json.Unmarshal([]byte(resp.Text()), &result)
        if err != nil {
            return nil, fmt.Errorf("failed to parse entities: %w", err)
        }

        return result, nil
    }
    ```
  </LangTabItem>
  <LangTabItem lang="python">
    Combine vector search with graph traversal for enhanced results:

    ```python
    import json
    from typing import List, Dict, Any

    # Graph-enhanced retrieval combining vector search with graph traversal
    async def graph_enhanced_retrieval(query: str) -> List[Dict[str, Any]]:
        try:
            # First, perform vector search
            vector_results = await retrieve_documents(query, k=3)
            
            # Enhance with graph traversal (would require Neo4j driver)
            enhanced_results = []
            for doc in vector_results:
                enhanced_doc = {
                    "document": doc,
                    "related_nodes": [],  # Would be populated by graph traversal
                }
                enhanced_results.append(enhanced_doc)
            
            return enhanced_results
        except Exception as error:
            print(f"Graph-enhanced retrieval failed: {error}")
            return []

    # Knowledge graph construction
    async def build_knowledge_graph(documents: List[Dict[str, Any]]) -> Dict[str, Any]:
        try:
            # Index documents first
            index_result = await index_documents(documents)
            
            if index_result["success"]:
                # Create relationships based on content similarity or metadata
                # This would involve direct Cypher queries to Neo4j
                print("Knowledge graph constructed with vector-enabled nodes")
                return {"graph_built": True, "nodes": len(documents)}
            else:
                return {"graph_built": False, "error": "Failed to index documents"}
        except Exception as error:
            print(f"Knowledge graph construction failed: {error}")
            return {"graph_built": False, "error": str(error)}

    # Entity relationship extraction
    async def extract_entity_relationships(text: str) -> Dict[str, Any]:
        try:
            prompt = f"""Extract entities and relationships from: {text}
            
            Format as JSON with entities and relationships arrays."""
            
            response = await ai.generate(
                model="googleai/gemini-2.5-flash",
                prompt=prompt
            )
            
            entities = json.loads(response.text)
            return entities
        except Exception as error:
            print(f"Entity extraction failed: {error}")
            return {"entities": [], "relationships": []}

    # Comprehensive knowledge graph workflow
    async def knowledge_graph_workflow(documents: List[Dict[str, Any]], query: str):
        # Build knowledge graph
        graph_result = await build_knowledge_graph(documents)
        
        # Extract entities from query
        query_entities = await extract_entity_relationships(query)
        
        # Perform graph-enhanced retrieval
        enhanced_results = await graph_enhanced_retrieval(query)
        
        return {
            "graph_construction": graph_result,
            "query_entities": query_entities,
            "enhanced_results": enhanced_results
        }
    ```
  </LangTabItem>
</LangTabs>

## Best Practices

### Graph Design

1. **Node Structure**: Design nodes with meaningful labels and properties
2. **Relationship Types**: Use descriptive relationship types for better traversal
3. **Index Strategy**: Create appropriate vector and property indexes
4. **Schema Design**: Plan your graph schema for optimal query performance

### Vector Integration

1. **Embedding Dimensions**: Match vector dimensions to your embedding model
2. **Similarity Functions**: Choose appropriate similarity functions (cosine, euclidean)
3. **Index Configuration**: Optimize vector index settings for your use case
4. **Hybrid Queries**: Combine vector search with graph traversal effectively

### Performance Optimization

1. **Query Optimization**: Use efficient Cypher queries for graph operations
2. **Index Management**: Maintain both vector and property indexes
3. **Connection Pooling**: Use connection pooling for better performance
4. **Memory Management**: Monitor memory usage for large graphs

### Production Deployment

1. **Clustering**: Use Neo4j clustering for high availability
2. **Backup Strategies**: Implement regular backup procedures
3. **Monitoring**: Monitor query performance and graph metrics
4. **Security**: Implement proper authentication and authorization

## Next Steps

- Learn about [RAG implementation](/unified-docs/rag) to build complete retrieval-augmented generation systems
- Explore [creating flows](/unified-docs/creating-flows) to build structured AI workflows with graph-enhanced search
- See [deployment guides](/unified-docs/deployment) for production deployment strategies
- Check out other vector database options for different use cases
