---
title: Pinecone Vector Database
description: Learn how to use Pinecone cloud vector database with Genkit across JavaScript, Go, and Python for RAG applications, semantic search, and vector storage.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Pinecone is a fully managed cloud vector database that provides high-performance vector search capabilities. The Pinecone integration with Genkit enables you to build powerful RAG (Retrieval-Augmented Generation) applications with semantic search, document indexing, and intelligent retrieval.

## Installation and Setup

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Install the Pinecone plugin:

    ```bash
    npm install genkitx-pinecone
    ```

    Configure the plugin when initializing Genkit:

    ```ts
    import { genkit } from 'genkit';
    import { pinecone } from 'genkitx-pinecone';
    import { googleAI } from '@genkit-ai/googleai';

    const ai = genkit({
      plugins: [
        pinecone([
          {
            indexId: 'my-knowledge-base',
            embedder: googleAI.embedder('gemini-embedding-001'),
          },
        ]),
      ],
    });
    ```

    ### API Key Configuration

    Set your Pinecone API key using one of these methods:

    ```bash
    # Environment variable (recommended)
    export PINECONE_API_KEY=your_pinecone_api_key
    ```

    ```ts
    // Or pass directly to plugin configuration
    pinecone([
      {
        indexId: 'my-knowledge-base',
        embedder: googleAI.embedder('gemini-embedding-001'),
        clientParams: {
          apiKey: 'your_pinecone_api_key',
        },
      },
    ])
    ```

    Get your API key from [Pinecone Console](https://app.pinecone.io/).
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    For Go applications, use the Pinecone Go client:

    ```bash
    go get github.com/pinecone-io/go-pinecone/pinecone
    ```

    ```go
    package main

    import (
        "context"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/pinecone"
        "github.com/firebase/genkit/go/plugins/googleai"
    )

    func main() {
        ctx := context.Background()
        g, err := genkit.Init(ctx,
            genkit.WithPlugins(
                &googleai.GoogleAI{},
                &pinecone.Pinecone{
                    APIKey: os.Getenv("PINECONE_API_KEY"),
                    Indexes: []pinecone.IndexConfig{
                        {
                            IndexID:  "my-knowledge-base",
                            Embedder: "googleai/gemini-embedding-001",
                        },
                    },
                },
            ),
        )
        if err != nil {
            log.Fatal(err)
        }
    }
    ```

    ### Environment Configuration

    ```bash
    export PINECONE_API_KEY=your_pinecone_api_key
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    For Python applications, install the Pinecone client:

    ```bash
    pip install pinecone-client genkit-plugin-pinecone
    ```

    ```python
    from genkit.ai import Genkit
    from genkit.plugins.pinecone import Pinecone
    from genkit.plugins.google_genai import GoogleGenAI

    ai = Genkit(
        plugins=[
            GoogleGenAI(),
            Pinecone(
                api_key=os.getenv("PINECONE_API_KEY"),
                indexes=[
                    {
                        "index_id": "my-knowledge-base",
                        "embedder": "googleai/gemini-embedding-001",
                    }
                ],
            ),
        ],
    )
    ```

    ### Environment Configuration

    ```bash
    export PINECONE_API_KEY=your_pinecone_api_key
    ```
  </TabItem>
</Tabs>

## Basic Usage

### Document Indexing

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Index documents for semantic search:

    ```ts
    import { pineconeIndexerRef } from 'genkitx-pinecone';
    import { Document } from 'genkit';

    // Prepare documents for indexing
    const documents: Document[] = [
      {
        content: 'Artificial Intelligence is transforming how we work and live.',
        metadata: {
          title: 'AI Overview',
          category: 'technology',
          source: 'blog',
        },
      },
      {
        content: 'Machine learning algorithms can identify patterns in large datasets.',
        metadata: {
          title: 'ML Patterns',
          category: 'data-science',
          source: 'research',
        },
      },
    ];

    // Index documents using the default configured index
    await ai.index({
      indexer: pineconeIndexerRef,
      documents,
    });

    // Or specify a specific index
    const knowledgeBaseIndexer = pineconeIndexerRef({
      indexId: 'my-knowledge-base',
    });

    await ai.index({
      indexer: knowledgeBaseIndexer,
      documents,
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Index documents for semantic search:

    ```go
    import (
        "context"
        "github.com/firebase/genkit/go/ai"
        "github.com/firebase/genkit/go/genkit"
    )

    func indexDocuments(ctx context.Context) error {
        documents := []ai.Document{
            {
                Content: "Artificial Intelligence is transforming how we work and live.",
                Metadata: map[string]interface{}{
                    "title":    "AI Overview",
                    "category": "technology",
                    "source":   "blog",
                },
            },
            {
                Content: "Machine learning algorithms can identify patterns in large datasets.",
                Metadata: map[string]interface{}{
                    "title":    "ML Patterns",
                    "category": "data-science",
                    "source":   "research",
                },
            },
        }

        // Index documents
        err := genkit.Index(ctx, g,
            ai.WithIndexer("pinecone/my-knowledge-base"),
            ai.WithDocuments(documents),
        )
        if err != nil {
            return fmt.Errorf("failed to index documents: %w", err)
        }

        return nil
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Index documents for semantic search:

    ```python
    from typing import List, Dict, Any

    # Prepare documents for indexing
    documents = [
        {
            "content": "Artificial Intelligence is transforming how we work and live.",
            "metadata": {
                "title": "AI Overview",
                "category": "technology",
                "source": "blog",
            },
        },
        {
            "content": "Machine learning algorithms can identify patterns in large datasets.",
            "metadata": {
                "title": "ML Patterns",
                "category": "data-science",
                "source": "research",
            },
        },
    ]

    # Index documents
    async def index_documents(docs: List[Dict[str, Any]], index_id: str = None):
        try:
            indexer = f"pinecone/{index_id}" if index_id else "pinecone/my-knowledge-base"
            
            await ai.index(
                indexer=indexer,
                documents=docs
            )
            
            return {"indexed": len(docs), "success": True}
        except Exception as error:
            print(f"Indexing failed: {error}")
            return {"indexed": 0, "success": False}
    ```
  </TabItem>
</Tabs>

### Document Retrieval

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Retrieve relevant documents using semantic search:

    ```ts
    import { pineconeRetrieverRef } from 'genkitx-pinecone';

    // Basic retrieval
    const query = "How does machine learning work?";
    const docs = await ai.retrieve({
      retriever: pineconeRetrieverRef,
      query,
    });

    console.log('Retrieved documents:', docs);

    // Advanced retrieval with specific index and options
    const knowledgeBaseRetriever = pineconeRetrieverRef({
      indexId: 'my-knowledge-base',
    });

    const advancedDocs = await ai.retrieve({
      retriever: knowledgeBaseRetriever,
      query,
      options: {
        k: 5, // Number of documents to retrieve
        filter: {
          category: 'technology', // Metadata filtering
        },
      },
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Retrieve relevant documents using semantic search:

    ```go
    // Basic retrieval
    func retrieveDocuments(ctx context.Context, query string) ([]ai.Document, error) {
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever("pinecone/my-knowledge-base"),
            ai.WithQuery(query),
        )
        if err != nil {
            return nil, fmt.Errorf("retrieval failed: %w", err)
        }

        return docs, nil
    }

    // Advanced retrieval with options
    func advancedRetrieve(ctx context.Context, query, indexID string, limit int, filter map[string]interface{}) ([]ai.Document, error) {
        retriever := fmt.Sprintf("pinecone/%s", indexID)
        
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever(retriever),
            ai.WithQuery(query),
            ai.WithOptions(map[string]interface{}{
                "k":      limit,
                "filter": filter,
            }),
        )
        if err != nil {
            return nil, fmt.Errorf("advanced retrieval failed: %w", err)
        }

        return docs, nil
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Retrieve relevant documents using semantic search:

    ```python
    from typing import List, Dict, Any, Optional

    # Basic retrieval
    async def retrieve_documents(query: str, index_id: str = "my-knowledge-base") -> List[Dict[str, Any]]:
        try:
            retriever = f"pinecone/{index_id}"
            docs = await ai.retrieve(
                retriever=retriever,
                query=query
            )
            return docs
        except Exception as error:
            print(f"Retrieval failed: {error}")
            return []

    # Advanced retrieval with options
    async def advanced_retrieve(
        query: str,
        index_id: str = "my-knowledge-base",
        limit: int = 5,
        filter_criteria: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        try:
            retriever = f"pinecone/{index_id}"
            
            options = {"k": limit}
            if filter_criteria:
                options["filter"] = filter_criteria
            
            docs = await ai.retrieve(
                retriever=retriever,
                query=query,
                options=options
            )
            
            return docs
        except Exception as error:
            print(f"Advanced retrieval failed: {error}")
            return []
    ```
  </TabItem>
</Tabs>

## RAG Implementation

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Build a complete RAG system with Pinecone:

    ```ts
    // RAG flow with Pinecone retrieval
    export const ragFlow = ai.defineFlow(
      {
        name: 'ragFlow',
        inputSchema: z.object({
          question: z.string(),
          indexId: z.string().optional(),
          maxResults: z.number().optional(),
        }),
        outputSchema: z.object({
          answer: z.string(),
          sources: z.array(z.object({
            content: z.string(),
            metadata: z.record(z.any()),
            score: z.number(),
          })),
        }),
      },
      async ({ question, indexId, maxResults = 3 }) => {
        // Retrieve relevant documents
        const retriever = indexId 
          ? pineconeRetrieverRef({ indexId })
          : pineconeRetrieverRef;

        const docs = await ai.retrieve({
          retriever,
          query: question,
          options: { k: maxResults },
        });

        // Build context from retrieved documents
        const context = docs
          .map(doc => `Source: ${doc.metadata?.title || 'Unknown'}\n${doc.content}`)
          .join('\n\n');

        // Generate answer using context
        const response = await ai.generate({
          model: googleAI.model('gemini-2.5-flash'),
          prompt: `Based on the following context, answer the question: "${question}"

Context:
${context}

Answer:`,
          config: {
            temperature: 0.3,
            maxTokens: 500,
          },
        });

        return {
          answer: response.text,
          sources: docs.map(doc => ({
            content: doc.content,
            metadata: doc.metadata || {},
            score: doc.score || 0,
          })),
        };
      },
    );
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Build a complete RAG system with Pinecone:

    ```go
    // RAG implementation
    func ragQuery(ctx context.Context, question, indexID string, maxResults int) (string, []ai.Document, error) {
        // Retrieve relevant documents
        retriever := fmt.Sprintf("pinecone/%s", indexID)
        docs, err := genkit.Retrieve(ctx, g,
            ai.WithRetriever(retriever),
            ai.WithQuery(question),
            ai.WithOptions(map[string]interface{}{
                "k": maxResults,
            }),
        )
        if err != nil {
            return "", nil, fmt.Errorf("retrieval failed: %w", err)
        }

        // Build context from retrieved documents
        var contextParts []string
        for _, doc := range docs {
            title := "Unknown"
            if t, ok := doc.Metadata["title"].(string); ok {
                title = t
            }
            contextParts = append(contextParts, fmt.Sprintf("Source: %s\n%s", title, doc.Content))
        }
        context := strings.Join(contextParts, "\n\n")

        // Generate answer using context
        prompt := fmt.Sprintf(`Based on the following context, answer the question: "%s"

Context:
%s

Answer:`, question, context)

        resp, err := genkit.Generate(ctx, g,
            ai.WithModel("googleai/gemini-2.5-flash"),
            ai.WithPrompt(prompt),
            ai.WithConfig(map[string]interface{}{
                "temperature": 0.3,
                "maxTokens":   500,
            }),
        )
        if err != nil {
            return "", nil, fmt.Errorf("generation failed: %w", err)
        }

        return resp.Text(), docs, nil
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Build a complete RAG system with Pinecone:

    ```python
    # RAG implementation
    async def rag_query(
        question: str,
        index_id: str = "my-knowledge-base",
        max_results: int = 3
    ) -> Dict[str, Any]:
        try:
            # Retrieve relevant documents
            retriever = f"pinecone/{index_id}"
            docs = await ai.retrieve(
                retriever=retriever,
                query=question,
                options={"k": max_results}
            )

            # Build context from retrieved documents
            context_parts = []
            for doc in docs:
                title = doc.get("metadata", {}).get("title", "Unknown")
                context_parts.append(f"Source: {title}\n{doc['content']}")
            
            context = "\n\n".join(context_parts)

            # Generate answer using context
            prompt = f'''Based on the following context, answer the question: "{question}"

Context:
{context}

Answer:'''

            response = await ai.generate(
                model="googleai/gemini-2.5-flash",
                prompt=prompt,
                config={
                    "temperature": 0.3,
                    "max_tokens": 500,
                }
            )

            return {
                "answer": response.text,
                "sources": [
                    {
                        "content": doc["content"],
                        "metadata": doc.get("metadata", {}),
                        "score": doc.get("score", 0),
                    }
                    for doc in docs
                ],
            }
        except Exception as error:
            print(f"RAG query failed: {error}")
            return {"answer": "I'm sorry, I couldn't find relevant information.", "sources": []}
    ```
  </TabItem>
</Tabs>

## Best Practices

### Index Management

1. **Choose appropriate dimensions**: Match your embedding model's output dimensions
2. **Use meaningful metadata**: Include searchable fields like category, date, source
3. **Optimize for your use case**: Consider pod type and replicas based on query volume
4. **Monitor performance**: Track query latency and accuracy metrics

### Query Optimization

1. **Use specific queries**: More specific queries yield better results
2. **Leverage metadata filtering**: Combine semantic search with metadata filters
3. **Tune similarity thresholds**: Adjust based on your quality requirements
4. **Implement query expansion**: Enhance queries with synonyms or context

### Cost Management

1. **Right-size your index**: Choose appropriate pod types and replica counts
2. **Use namespaces**: Organize data efficiently within indexes
3. **Monitor usage**: Track query volume and storage costs
4. **Implement caching**: Cache frequent queries to reduce API calls

## Next Steps

- Learn about [RAG implementation](/unified-docs/rag) to build complete retrieval-augmented generation systems
- Explore [creating flows](/unified-docs/creating-flows) to build structured AI workflows with vector search
- See [deployment guides](/unified-docs/deployment) for production deployment strategies
- Check out other vector database options for different use cases
