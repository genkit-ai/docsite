---
title: Observability and monitoring
description: Learn about Genkit's observability features, including tracing, metrics collection, logging, and monitoring capabilities across JavaScript, Go, and Python.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Genkit provides robust observability features to help you understand and debug your AI applications. These capabilities include tracing, metrics collection, logging, and monitoring, with different levels of support across languages.

## Availability and Approach

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    JavaScript provides comprehensive observability features including:
    - Automatic OpenTelemetry tracing and metrics
    - Built-in Developer UI for trace inspection
    - Centralized logging system with configurable levels
    - Firebase Genkit Monitoring integration
    - Export to custom observability tools
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Go provides core observability features including:
    - Full OpenTelemetry instrumentation
    - Developer UI trace inspection
    - Google Cloud Operations Suite integration
    - Trace store for development debugging
    - Custom telemetry export capabilities
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Python has basic observability features:
    - Limited OpenTelemetry support
    - Basic logging capabilities
    - Framework-specific monitoring (e.g., Flask integration)
    - Manual instrumentation may be required
  </TabItem>
</Tabs>

## Automatic tracing and metrics

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Genkit automatically collects traces and metrics without requiring explicit configuration, allowing you to observe and debug your Genkit code's behavior in the Developer UI. Genkit stores these traces, enabling you to analyze your Genkit flows step-by-step with detailed input/output logging and statistics.

    ```typescript
    import { genkit } from 'genkit';
    import { googleAI } from '@genkit-ai/googleai';

    const ai = genkit({
      plugins: [googleAI()],
      // Tracing is automatically enabled
    });

    // All flows, tools, and generation calls are automatically traced
    const myFlow = ai.defineFlow({
      name: 'myFlow',
      inputSchema: z.string(),
      outputSchema: z.string(),
    }, async (input) => {
      // This entire flow execution will be traced
      const result = await ai.generate({
        prompt: `Process this: ${input}`,
      });
      return result.text;
    });
    ```

    In production, Genkit can export traces and metrics to Firebase Genkit Monitoring for further analysis.
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    Genkit is fully instrumented with [OpenTelemetry](https://opentelemetry.io/) and provides hooks to export telemetry data. The trace store feature lets you inspect your traces for your flow runs in the Genkit Developer UI.

    ```go
    import (
        "context"
        "github.com/firebase/genkit/go/genkit"
        "github.com/firebase/genkit/go/plugins/googlecloud"
    )

    func main() {
        ctx := context.Background()
        
        // Initialize with Google Cloud plugin for telemetry export
        g, err := genkit.Init(ctx, 
            genkit.WithPlugins(&googlecloud.GoogleCloud{}),
        )
        if err != nil {
            panic(err)
        }

        // All flows and generation calls are automatically traced
        flow := genkit.DefineFlow(g, "myFlow", 
            func(ctx context.Context, input string) (string, error) {
                // This entire flow execution will be traced
                resp, err := genkit.Generate(ctx, g,
                    ai.WithPrompt("Process this: " + input),
                )
                if err != nil {
                    return "", err
                }
                return resp.Text(), nil
            },
        )
    }
    ```

    This feature is enabled whenever you run a Genkit flow in a dev environment (such as when using `genkit start` or `genkit flow:run`).
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Python has limited built-in observability features. You may need to implement custom tracing and monitoring:

    ```python
    import logging
    from genkit.ai import Genkit
    from genkit.plugins.google_genai import GoogleGenai

    # Configure basic logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    ai = Genkit(plugins=[GoogleGenai()])

    @ai.flow()
    async def my_flow(input_text: str, ctx):
        # Add manual logging for observability
        logger.info(f"Processing input: {input_text}")
        
        try:
            result = await ai.generate(
                prompt=f"Process this: {input_text}",
            )
            logger.info("Generation completed successfully")
            return result.text
        except Exception as e:
            logger.error(f"Generation failed: {e}")
            raise
    ```

    For more advanced observability, consider integrating with external monitoring tools or using framework-specific monitoring solutions.
  </TabItem>
</Tabs>

## Logging

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    Genkit provides a centralized logging system that you can configure using the logging module. One advantage of using the Genkit-provided logger is that it automatically exports logs to Genkit Monitoring when the Firebase Telemetry plugin is enabled.

    ```typescript
    import { logger } from 'genkit/logging';

    // Set the desired log level
    logger.setLogLevel('debug');

    // Use the logger in your flows
    const myFlow = ai.defineFlow({
      name: 'myFlow',
      inputSchema: z.string(),
      outputSchema: z.string(),
    }, async (input) => {
      logger.info('Starting flow execution', { input });
      
      try {
        const result = await ai.generate({
          prompt: `Process this: ${input}`,
        });
        
        logger.info('Flow completed successfully', { 
          inputLength: input.length,
          outputLength: result.text.length 
        });
        
        return result.text;
      } catch (error) {
        logger.error('Flow execution failed', { error, input });
        throw error;
      }
    });
    ```

    Available log levels: `debug`, `info`, `warn`, `error`
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    In Go, you can use the standard logging package or structured logging libraries:

    ```go
    import (
        "log"
        "context"
        "github.com/firebase/genkit/go/genkit"
    )

    func myFlow(ctx context.Context, input string) (string, error) {
        log.Printf("Starting flow execution with input: %s", input)
        
        resp, err := genkit.Generate(ctx, g,
            ai.WithPrompt("Process this: " + input),
        )
        if err != nil {
            log.Printf("Flow execution failed: %v", err)
            return "", err
        }
        
        log.Printf("Flow completed successfully, output length: %d", len(resp.Text()))
        return resp.Text(), nil
    }
    ```

    For structured logging, consider using libraries like `logrus` or `zap`:

    ```go
    import (
        "github.com/sirupsen/logrus"
    )

    func myFlowWithStructuredLogging(ctx context.Context, input string) (string, error) {
        logrus.WithFields(logrus.Fields{
            "input_length": len(input),
            "flow_name":    "myFlow",
        }).Info("Starting flow execution")
        
        // ... flow logic
        
        logrus.WithFields(logrus.Fields{
            "output_length": len(result),
            "success":       true,
        }).Info("Flow completed")
        
        return result, nil
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Use Python's standard logging module or integrate with your preferred logging framework:

    ```python
    import logging
    import structlog

    # Standard logging
    logger = logging.getLogger(__name__)

    @ai.flow()
    async def my_flow(input_text: str, ctx):
        logger.info("Starting flow execution", extra={
            "input_length": len(input_text),
            "flow_name": "my_flow"
        })
        
        try:
            result = await ai.generate(
                prompt=f"Process this: {input_text}",
            )
            
            logger.info("Flow completed successfully", extra={
                "input_length": len(input_text),
                "output_length": len(result.text)
            })
            
            return result.text
        except Exception as e:
            logger.error("Flow execution failed", extra={
                "error": str(e),
                "input_length": len(input_text)
            })
            raise

    # Or use structured logging with structlog
    struct_logger = structlog.get_logger()

    @ai.flow()
    async def my_structured_flow(input_text: str, ctx):
        struct_logger.info("flow_started", 
                          input_length=len(input_text),
                          flow_name="my_structured_flow")
        # ... flow logic
    ```
  </TabItem>
</Tabs>

## Developer UI integration

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    The Genkit Developer UI provides detailed trace viewing and debugging capabilities. When you run your application with `genkit start`, you can:

    - View detailed traces of flow executions
    - Inspect input/output at each step
    - Analyze performance metrics
    - Debug errors with full stack traces
    - Monitor token usage and costs

    ```bash
    # Start your app with the Developer UI
    genkit start -- npm run dev

    # The Developer UI will be available at http://localhost:4000
    ```

    All traces are automatically captured and displayed in the UI without additional configuration.
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    The Developer UI works the same way for Go applications. When you run your application in development mode, traces are automatically captured:

    ```bash
    # Start your Go app with the Developer UI
    genkit start -- go run main.go

    # The Developer UI will be available at http://localhost:4000
    ```

    You can inspect:
    - Flow execution traces
    - Generation requests and responses
    - Tool call details
    - Performance metrics
    - Error information
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    Python applications can also use the Developer UI, though with potentially limited trace details:

    ```bash
    # Start your Python app with the Developer UI
    genkit start -- python main.py

    # The Developer UI will be available at http://localhost:4000
    ```

    The level of trace detail may vary depending on the Python implementation and available instrumentation.
  </TabItem>
</Tabs>

## Production monitoring

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    For production environments, Genkit integrates with Firebase Genkit Monitoring and other observability platforms:

    ### Firebase Genkit Monitoring

    The [Genkit Monitoring](https://console.firebase.google.com/project/_/genai_monitoring) dashboard helps you understand the overall health of your Genkit features. It is useful for debugging stability and content issues that may indicate problems with your LLM prompts and/or Genkit Flows.

    ```typescript
    import { genkit } from 'genkit';
    import { firebase } from '@genkit-ai/firebase';

    const ai = genkit({
      plugins: [
        firebase({
          // Enables telemetry export to Firebase
          telemetry: true,
        }),
      ],
    });
    ```

    ### Custom observability platforms

    You can export OpenTelemetry data to other platforms:

    ```typescript
    import { genkit } from 'genkit';
    import { opentelemetry } from '@genkit-ai/opentelemetry';

    const ai = genkit({
      plugins: [
        opentelemetry({
          endpoint: 'https://your-otel-collector.com',
          headers: {
            'Authorization': 'Bearer your-token',
          },
        }),
      ],
    });
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    For production monitoring, use the Google Cloud plugin to export telemetry to Cloud's operations suite:

    ```go
    import (
        "github.com/firebase/genkit/go/plugins/googlecloud"
    )

    func main() {
        ctx := context.Background()
        
        g, err := genkit.Init(ctx, 
            genkit.WithPlugins(&googlecloud.GoogleCloud{
                // Configure telemetry export
                ProjectID: "your-project-id",
            }),
        )
        if err != nil {
            panic(err)
        }
        
        // Your flows will now export telemetry to Google Cloud
    }
    ```

    This provides:
    - Distributed tracing in Cloud Trace
    - Metrics in Cloud Monitoring
    - Logs in Cloud Logging
    - Error reporting in Cloud Error Reporting
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    For production monitoring in Python, you'll typically need to integrate with external monitoring solutions:

    ```python
    import logging
    from opentelemetry import trace
    from opentelemetry.exporter.cloud_trace import CloudTraceSpanExporter
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.trace.export import BatchSpanProcessor

    # Configure OpenTelemetry for Google Cloud
    trace.set_tracer_provider(TracerProvider())
    tracer = trace.get_tracer(__name__)

    cloud_trace_exporter = CloudTraceSpanExporter()
    span_processor = BatchSpanProcessor(cloud_trace_exporter)
    trace.get_tracer_provider().add_span_processor(span_processor)

    @ai.flow()
    async def monitored_flow(input_text: str, ctx):
        with tracer.start_as_current_span("my_flow") as span:
            span.set_attribute("input.length", len(input_text))
            
            try:
                result = await ai.generate(
                    prompt=f"Process this: {input_text}",
                )
                span.set_attribute("output.length", len(result.text))
                return result.text
            except Exception as e:
                span.record_exception(e)
                span.set_status(trace.Status(trace.StatusCode.ERROR))
                raise
    ```
  </TabItem>
</Tabs>

## Best practices

### Development monitoring

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    - Use the Developer UI for real-time debugging
    - Set appropriate log levels for development vs production
    - Monitor token usage and costs during development
    - Use trace inspection to optimize flow performance
    - Test error scenarios and review error traces
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    - Leverage the Developer UI for flow debugging
    - Use structured logging for better searchability
    - Monitor goroutine usage in concurrent flows
    - Profile memory usage for long-running applications
    - Test error handling and recovery scenarios
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    - Implement comprehensive logging throughout your flows
    - Use async-compatible logging libraries
    - Monitor memory usage and garbage collection
    - Test error scenarios thoroughly
    - Consider using APM tools for detailed insights
  </TabItem>
</Tabs>

### Production monitoring

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    - Enable Firebase Genkit Monitoring for comprehensive insights
    - Set up alerts for error rates and latency thresholds
    - Monitor token usage and costs
    - Track flow success rates and performance metrics
    - Implement custom metrics for business-specific KPIs
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    - Use Google Cloud Operations Suite for full observability
    - Set up monitoring dashboards for key metrics
    - Configure alerting for error rates and latency
    - Monitor resource usage and scaling metrics
    - Implement health checks and readiness probes
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    - Integrate with your organization's monitoring stack
    - Set up comprehensive error tracking
    - Monitor application performance and resource usage
    - Implement custom metrics collection
    - Use distributed tracing for complex workflows
  </TabItem>
</Tabs>

### Security and privacy

<Tabs syncKey="language">
  <TabItem label="JavaScript" icon="seti:javascript">
    - Avoid logging sensitive data in traces
    - Use log level filtering to control information exposure
    - Implement proper access controls for monitoring dashboards
    - Consider data retention policies for traces and logs
    - Sanitize user inputs in log messages
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    - Implement log sanitization for sensitive data
    - Use structured logging to control field exposure
    - Configure proper IAM for monitoring resources
    - Implement trace sampling for high-volume applications
    - Consider data residency requirements
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    - Implement data sanitization in logging
    - Use environment-specific log levels
    - Secure monitoring endpoints and dashboards
    - Consider GDPR and privacy requirements
    - Implement proper error handling to avoid data leaks
  </TabItem>
</Tabs>

## Next steps

- Learn about [developer tools](/unified-docs/developer-tools) for local development and debugging
- Explore [evaluation](/unified-docs/evaluation) to measure and improve your application quality
- See [creating flows](/unified-docs/creating-flows) to build observable AI workflows
- Check out [generating content](/unified-docs/generating-content) for understanding traced generation calls
