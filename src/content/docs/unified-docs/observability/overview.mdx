---
title: Observability Overview
description: Get started with Genkit's observability features, including local development tools, production monitoring, and telemetry configuration across JavaScript, Go, and Python.
---

import LanguageSelector from '../../../../components/LanguageSelector.astro';
import LanguageContent from '../../../../components/LanguageContent.astro';

<LanguageSelector />

This guide provides an overview of Genkit's observability capabilities and helps you get started with monitoring your AI workflows in both development and production environments.

## What is Observability?

Observability in Genkit refers to the ability to understand the internal state of your AI workflows by examining their outputs. This includes:

- **Tracing**: Following the execution path of your flows step-by-step
- **Metrics**: Collecting quantitative data about performance and usage
- **Logging**: Recording events and debugging information
- **Monitoring**: Real-time visibility into system health and performance

## Observability Layers

### 1. Local Development

During development, Genkit provides built-in observability through the Developer UI:

- **Automatic trace collection**: No configuration required
- **Interactive debugging**: Step through flow execution
- **Real-time inspection**: View inputs, outputs, and intermediate states
- **Performance analysis**: Identify bottlenecks and optimization opportunities

### 2. Production Monitoring

For deployed applications, Genkit offers production-grade monitoring:

- **Firebase Genkit Monitoring**: Integrated dashboard for Firebase projects
- **OpenTelemetry export**: Send data to any observability platform
- **Custom metrics**: Application-specific monitoring
- **Alerting and dashboards**: Proactive monitoring and visualization

## Key Features

### Automatic Instrumentation

Genkit automatically instruments your code to collect telemetry data:

<LanguageContent lang="js">
```ts
    import { genkit } from 'genkit';
    import { googleAI } from '@genkit-ai/googleai';

    // Observability is automatically enabled
    const ai = genkit({
      plugins: [googleAI()],
    });

    // All flows are automatically traced
    export const myFlow = ai.defineFlow(
      { name: 'myFlow' },
      async (input) => {
        // This execution will be automatically traced
        return await ai.generate({
          model: 'gemini-1.5-flash',
          prompt: `Process this: ${input}`,
        });
      }
    );
    ```
</LanguageContent>

<LanguageContent lang="go">
```go
    import (
        "context"
        "github.com/firebase/genkit/go/genkit"
    )

    func main() {
        ctx := context.Background()
        
        // Observability is built-in
        g, err := genkit.Init(ctx)
        if err != nil {
            log.Fatal(err)
        }

        // Flows are automatically instrumented
        myFlow := genkit.DefineFlow(g, "myFlow",
            func(ctx context.Context, input string) (string, error) {
                // Execution is automatically traced
                return processData(input)
            })
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
```python
    from genkit.ai import Genkit

    # Observability is enabled by default
    ai = Genkit()

    @ai.flow()
    async def my_flow(input: str) -> str:
        # This flow execution is automatically traced
        result = await ai.generate(
            model='gemini-1.5-flash',
            prompt=f'Process this: {input}',
        )
        return result.text
    ```
</LanguageContent>

### Developer UI Integration

The Developer UI provides comprehensive observability during development:

1. **Flow Execution Traces**: See every step of your flow execution
2. **Input/Output Inspection**: Examine data at each stage
3. **Performance Metrics**: View timing and resource usage
4. **Error Analysis**: Debug failures with detailed stack traces
5. **Interactive Testing**: Run flows with different inputs

### Production Telemetry

For production environments, Genkit exports telemetry data to monitoring platforms:

- **Metrics**: Performance indicators, error rates, usage statistics
- **Traces**: Detailed execution paths for debugging
- **Logs**: Structured logging with context
- **Custom Events**: Application-specific monitoring points

## Getting Started

### 1. Local Development

Start the Developer UI to begin observing your flows:

```bash
# JavaScript
npx genkit start

# Go
genkit start

# Python
python -m genkit start
```

### 2. Production Setup

Enable production monitoring by configuring telemetry export:

<LanguageContent lang="js">
```bash
    # Install Firebase plugin
    npm install @genkit-ai/firebase

    # Enable monitoring
    export ENABLE_FIREBASE_MONITORING=true
    ```
</LanguageContent>

<LanguageContent lang="go">
```bash
    # Install Google Cloud plugin
    go get github.com/firebase/genkit/go/plugins/googlecloud
    ```
</LanguageContent>

<LanguageContent lang="python">
```bash
    # Install monitoring dependencies
    pip install genkit[monitoring]
    ```
</LanguageContent>

### 3. Configure Permissions

Set up the required Google Cloud permissions:

- **Monitoring Metric Writer** (`roles/monitoring.metricWriter`)
- **Cloud Trace Agent** (`roles/cloudtrace.agent`)
- **Logs Writer** (`roles/logging.logWriter`)

## Observability Best Practices

### Development

1. **Use the Developer UI**: Take advantage of built-in tracing
2. **Test with realistic data**: Use production-like inputs for testing
3. **Monitor performance**: Identify bottlenecks early
4. **Debug systematically**: Use traces to understand flow behavior

### Production

1. **Implement monitoring**: Set up dashboards and alerts
2. **Control costs**: Use sampling and filtering appropriately
3. **Protect sensitive data**: Configure input/output logging carefully
4. **Regular reviews**: Analyze metrics and optimize performance

### Security

1. **Secure credentials**: Use proper IAM roles and service accounts
2. **Data privacy**: Disable logging of sensitive information
3. **Network security**: Ensure secure connections to monitoring services
4. **Access control**: Limit who can view observability data

## Common Use Cases

### Debugging Flow Issues

Use observability to diagnose problems:

1. **Trace analysis**: Follow execution path to find failures
2. **Input/output inspection**: Verify data transformations
3. **Performance profiling**: Identify slow operations
4. **Error correlation**: Connect errors to specific inputs or conditions

### Performance Optimization

Leverage metrics to improve performance:

1. **Latency analysis**: Find and optimize slow operations
2. **Resource usage**: Monitor memory and CPU consumption
3. **Throughput measurement**: Track requests per second
4. **Cost optimization**: Identify expensive operations

### Production Monitoring

Maintain system health in production:

1. **Health dashboards**: Monitor key metrics and trends
2. **Alerting**: Get notified of issues before users are affected
3. **Capacity planning**: Use metrics to plan for growth
4. **Incident response**: Use traces and logs for troubleshooting

## Next Steps

- Learn about [authentication and setup](/unified-docs/observability/authentication) for production monitoring
- Explore [advanced configuration](/unified-docs/observability/advanced-configuration) options
- Check out [troubleshooting](/unified-docs/observability/troubleshooting) common issues
- Read the main [observability and monitoring](/unified-docs/observability-monitoring) guide for detailed implementation
