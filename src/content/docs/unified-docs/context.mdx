---
title: Passing information through context
description: Learn how Genkit's context object propagates generation and execution information throughout your application, making it available to flows, tools, and prompts across different languages.
---

import LanguageSelector from '../../../components/LanguageSelector.astro';
import LanguageContent from '../../../components/LanguageContent.astro';

<LanguageSelector />

There are different categories of information that a developer working
with an LLM may be handling simultaneously:

- **Input:** Information that is directly relevant to guide the LLM's response
  for a particular call. An example of this is the text that needs to be
  summarized.
- **Generation Context:** Information that is relevant to the LLM, but isn't
  specific to the call. An example of this is the current time or a user's name.
- **Execution Context:** Information that is important to the code surrounding
  the LLM call but not to the LLM itself. An example of this is a user's
  current auth token.

Genkit provides mechanisms to propagate generation and execution context throughout the process, though the implementation varies by language.

## Availability and Approach

<LanguageContent lang="js">
JavaScript provides a comprehensive `context` object that can propagate generation and execution context throughout the process. This context is made available to all actions including [flows](/unified-docs/creating-flows), [tools](/unified-docs/tool-calling), and [prompts](/unified-docs/dotprompt).

    Context is automatically propagated to all actions called within the scope of execution: Context passed to a flow is made available to prompts executed within the flow. Context passed to the `generate()` method is available to tools called within the generation loop.
</LanguageContent>

<LanguageContent lang="go">
Go uses the standard `context.Context` package for execution context, which is different from Genkit's JavaScript context object. Go's context is primarily used for cancellation, deadlines, and request-scoped values.

    For application-specific context (like user authentication), you typically pass this information as parameters to your functions or store it in the Go context using context values.
</LanguageContent>

<LanguageContent lang="python">
Python has limited context features, primarily available through framework integrations like Flask. Context is mainly used for request-scoped information like authentication.

    Python context is typically handled through the framework's request context or by passing context explicitly to functions.
</LanguageContent>

## Why is context important?

As a best practice, you should provide the minimum amount of information to the
LLM that it needs to complete a task. This is important for multiple reasons:

- The less extraneous information the LLM has, the more likely it is to perform
  well at its task.
- If an LLM needs to pass around information like user or account IDs to tools,
  it can potentially be tricked into leaking information.

Context gives you a side channel of information that can be used by any of your
code but doesn't necessarily have to be sent to the LLM. As an example, it can
allow you to restrict tool queries to the current user's available scope.

## Context structure

<LanguageContent lang="js">
Context must be an object, but its properties are yours to decide. In some
    situations Genkit automatically populates context. For example, when using
    [persistent sessions](/docs/chat) the `state` property is automatically added to
    context.

    One of the most common uses of context is to store information about the current
    user. We recommend adding auth context in the following format:

    ```js
    {
      auth: {
        uid: "...", // the user's unique identifier
        token: {...}, // the decoded claims of a user's id token
        rawToken: "...", // the user's raw encoded id token
        // ...any other fields
      }
    }
    ```

    The context object can store any information that you might need to know
    somewhere else in the flow of execution.
</LanguageContent>

<LanguageContent lang="go">
In Go, you typically use the standard `context.Context` for execution context and pass application-specific data as function parameters or context values:

    ```go
    type UserContext struct {
        UID      string
        Token    string
        RawToken string
    }

    // Pass as function parameter
    func myFlow(ctx context.Context, userCtx UserContext, input string) (string, error) {
        // Use userCtx for authorization checks
        if userCtx.UID == "" {
            return "", fmt.Errorf("user not authenticated")
        }
        // ... rest of flow
    }

    // Or store in Go context
    type contextKey string
    const userContextKey contextKey = "user"

    func withUserContext(ctx context.Context, userCtx UserContext) context.Context {
        return context.WithValue(ctx, userContextKey, userCtx)
    }

    func getUserContext(ctx context.Context) (UserContext, bool) {
        userCtx, ok := ctx.Value(userContextKey).(UserContext)
        return userCtx, ok
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
In Python, context is typically handled through framework-specific mechanisms:

    ```python
    # Flask example with context provider
    async def my_context_provider(request):
        auth_header = request.headers.get('authorization')
        username = parse_request_header(auth_header)
        return {'username': username}

    @app.post('/my_endpoint')
    @genkit_flask_handler(ai, context_provider=my_context_provider)
    @ai.flow()
    async def my_flow(input_data: str, ctx):
        # Access context through ctx.context
        if not ctx.context.get('username'):
            raise GenkitError(status='UNAUTHENTICATED', message='user not provided')
        
        # Use context in your flow
        return await ai.generate(
            prompt=f'Process this for user {ctx.context.get("username")}: {input_data}',
        )
    ```
</LanguageContent>

## Use context in an action

<LanguageContent lang="js">
To use context within an action, you can access the context helper
    that is automatically supplied to your function definition:

    ### Flow

    ```ts
    const summarizeHistory = ai.defineFlow({
      name: 'summarizeMessages',
      inputSchema: z.object({friendUid: z.string()}),
      outputSchema: z.string()
    }, async ({friendUid}, {context}) => {
      if (!context.auth?.uid) throw new Error("Must supply auth context.");
      const messages = await listMessagesBetween(friendUid, context.auth.uid);
      const {text} = await ai.generate({
        prompt:
          `Summarize the content of these messages: ${JSON.stringify(messages)}`,
      });
      return text;
    });
    ```

    ### Tool

    ```ts
    const searchNotes = ai.defineTool({
      name: 'searchNotes',
      description: "search the current user's notes for info",
      inputSchema: z.object({query: z.string()}),
      outputSchema: z.array(NoteSchema)
    }, async ({query}, {context}) => {
      if (!context.auth?.uid) throw new Error("Must be called by a signed-in user.");
      return searchUserNotes(context.auth.uid, query);
    });
    ```

    ### Prompt file

    When using [Dotprompt templates](/unified-docs/dotprompt), context is made available with the
    `@` variable prefix. For example, a context object of
    `{auth: {name: 'Michael'}}` could be accessed in the prompt template like so.

    ```dotprompt
    ---
    input:
      schema:
        pirateStyle?: boolean
    ---

    {{#if pirateStyle}}Avast, {{@auth.name}}, how be ye today?{{else}}Hello, {{@auth.name}}, how are you today?{{/if}}
    ```
</LanguageContent>

<LanguageContent lang="go">
In Go, you typically pass context information as function parameters or retrieve it from the Go context:

    ```go
    // Using function parameters
    func summarizeHistory(ctx context.Context, userCtx UserContext, friendUID string) (string, error) {
        if userCtx.UID == "" {
            return "", fmt.Errorf("must supply auth context")
        }
        
        messages, err := listMessagesBetween(friendUID, userCtx.UID)
        if err != nil {
            return "", err
        }
        
        resp, err := genkit.Generate(ctx, g,
            ai.WithPrompt("Summarize the content of these messages: %s", string(messages)),
        )
        if err != nil {
            return "", err
        }
        
        return resp.Text(), nil
    }

    // Using Go context values
    func searchNotes(ctx context.Context, query string) ([]Note, error) {
        userCtx, ok := getUserContext(ctx)
        if !ok || userCtx.UID == "" {
            return nil, fmt.Errorf("must be called by a signed-in user")
        }
        
        return searchUserNotes(userCtx.UID, query)
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
In Python, context is accessed through the framework's context mechanism:

    ```python
    @ai.flow()
    async def summarize_history(friend_uid: str, ctx):
        if not ctx.context.get('username'):
            raise GenkitError(status='UNAUTHENTICATED', message='user not provided')
        
        # Use context for authorization
        messages = await list_messages_between(friend_uid, ctx.context.get('username'))
        
        response = await ai.generate(
            prompt=f'Summarize the content of these messages: {messages}',
        )
        return response.text

    @ai.tool()
    def search_notes(query: str, ctx) -> list[Note]:
        """Search the current user's notes for info"""
        if not ctx.context.get('username'):
            raise GenkitError(status='UNAUTHENTICATED', message='must be called by a signed-in user')
        
        return search_user_notes(ctx.context.get('username'), query)
    ```
</LanguageContent>

## Provide context at runtime

<LanguageContent lang="js">
To provide context to an action, you pass the context object as an option
    when calling the action.

    ### Flows

    ```ts
    const summarizeHistory = ai.defineFlow(/* ... */);
    
    const summary = await summarizeHistory(friend.uid, {
      context: { auth: currentUser },
    });
    ```

    ### Generation

    ```ts
    const { text } = await ai.generate({
      prompt: "Find references to ocelots in my notes.",
      // the context will propagate to tool calls
      tools: [searchNotes],
      context: { auth: currentUser },
    });
    ```

    ### Prompts

    ```ts
    const helloPrompt = ai.prompt("sayHello");
    helloPrompt({ pirateStyle: true }, { context: { auth: currentUser } });
    ```
</LanguageContent>

<LanguageContent lang="go">
In Go, you pass context information as function parameters or through the Go context:

    ```go
    // Using function parameters
    userCtx := UserContext{
        UID:   currentUser.UID,
        Token: currentUser.Token,
    }

    summary, err := summarizeHistory(ctx, userCtx, friend.UID)

    // Using Go context values
    ctx = withUserContext(ctx, userCtx)
    notes, err := searchNotes(ctx, "ocelots")

    // For generation with tools
    resp, err := genkit.Generate(ctx, g,
        ai.WithPrompt("Find references to ocelots in my notes."),
        ai.WithTools(searchNotesTool),
    )
    ```
</LanguageContent>

<LanguageContent lang="python">
In Python, context is typically provided through framework mechanisms:

    ```python
    # Context is provided through the context provider
    @app.post('/summarize')
    @genkit_flask_handler(ai, context_provider=my_context_provider)
    @ai.flow()
    async def summarize_endpoint(friend_uid: str, ctx):
        # Context is automatically available through ctx.context
        return await summarize_history(friend_uid, ctx)

    # For direct generation
    response = await ai.generate(
        prompt="Find references to ocelots in my notes.",
        tools=['search_notes'],
        # Context handling depends on the specific Python implementation
    )
    ```
</LanguageContent>

## Context propagation and overrides

<LanguageContent lang="js">
By default, when you provide context it is automatically propagated to all
    actions called as a result of your original call. If your flow calls other
    flows, or your generation calls tools, the same context is provided.

    If you wish to override context within an action, you can pass a different
    context object to replace the existing one:

    ```ts
    const otherFlow = ai.defineFlow(/* ... */);

    const myFlow = ai.defineFlow(
      {
        // ...
      },
      (input, { context }) => {
        // override the existing context completely
        otherFlow(
          {
            /*...*/
          },
          { context: { newContext: true } },
        );
        // or selectively override
        otherFlow(
          {
            /*...*/
          },
          { context: { ...context, updatedContext: true } },
        );
      },
    );
    ```

    When context is replaced, it propagates the same way. In this example,
    any actions that `otherFlow` called during its execution would inherit the
    overridden context.
</LanguageContent>

<LanguageContent lang="go">
In Go, context propagation is handled through the standard `context.Context` package and explicit parameter passing:

    ```go
    func myFlow(ctx context.Context, userCtx UserContext, input string) (string, error) {
        // Override context for a specific call
        newUserCtx := UserContext{
            UID:   userCtx.UID,
            Token: "new-token",
        }
        
        result, err := otherFlow(ctx, newUserCtx, input)
        if err != nil {
            return "", err
        }
        
        // Or modify Go context
        newCtx := withUserContext(ctx, newUserCtx)
        return anotherFlow(newCtx, input)
    }
    ```
</LanguageContent>

<LanguageContent lang="python">
In Python, context propagation depends on the framework and how you structure your application:

    ```python
    @ai.flow()
    async def my_flow(input_data: str, ctx):
        # Context is available through ctx.context
        current_context = ctx.context
        
        # For calling other functions, you typically pass context explicitly
        # or rely on the framework's context management
        result = await other_function(input_data, current_context)
        
        return result
    ```
</LanguageContent>

## Best practices

### Security considerations

<LanguageContent lang="js">
- Never include sensitive information in context that might be logged
    - Validate context data before using it for authorization decisions
    - Use context to restrict tool access to user-scoped data
    - Consider using short-lived tokens in context
</LanguageContent>

<LanguageContent lang="go">
- Use Go's context package for cancellation and deadlines
    - Store user-specific data in custom types, not directly in Go context
    - Validate all context data before using it for authorization
    - Consider using middleware for consistent context handling
</LanguageContent>

<LanguageContent lang="python">
- Validate context data in your context provider
    - Use framework-specific security best practices
    - Keep context data minimal and focused on the current request
    - Implement proper error handling for missing or invalid context
</LanguageContent>

### Performance considerations

<LanguageContent lang="js">
- Keep context objects small to minimize memory usage
    - Avoid storing large objects or functions in context
    - Use context for metadata, not for large data payloads
</LanguageContent>

<LanguageContent lang="go">
- Use Go context values sparingly - prefer explicit parameters
    - Don't store large objects in Go context
    - Use context primarily for request-scoped metadata
</LanguageContent>

<LanguageContent lang="python">
- Keep context data minimal and request-scoped
    - Avoid expensive operations in context providers
    - Cache context data when appropriate
</LanguageContent>

## Next steps

- Learn about [creating flows](/unified-docs/creating-flows) to build workflows that use context
- Explore [tool calling](/unified-docs/tool-calling) to understand how context propagates to tools
- See [developer tools](/unified-docs/developer-tools) for debugging context-aware applications
- Check out [generating content](/unified-docs/generating-content) for using context in generation calls
